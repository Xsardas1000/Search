Interactive Browsing and Navigation

in Relational Databases

Minsuk Kahng, Shamkant B. Navathe, John T. Stasko, and Duen Horng (Polo) Chau

Georgia Institute of Technology

Atlanta, GA, USA

kahng@gatech.edu, sham@cc.gatech.edu, stasko@cc.gatech.edu, polo@gatech.edu

6
1
0
2

 
r
a

M
8

 

 
 
]

B
D
.
s
c
[
 
 

1
v
1
7
3
2
0

.

3
0
6
1
:
v
i
X
r
a

ABSTRACT
Although database researchers have devoted considerable ef-
fort to helping database users formulate queries, many users
still Ô¨Ånd it challenging to specify queries that involve joining
tables. To help users construct join queries for exploring re-
lational databases, we propose Etable, a novel presentation
data model that provides users with a presentation-level in-
teractive view. This view compactly presents one-to-many
and many-to-many relationships within a single enriched ta-
ble by allowing a cell to contain a set of entity references.
Users can directly interact with the table and the entity
references to specify navigation operators to incrementally
construct complex queries. To enable users to explore data
on a conceptual entity-relationship level, we also introduce a
graph-based model, called typed graph model that provides
an abstraction of relational databases. In a user study, par-
ticipants performed a range of database querying tasks faster
with Etable than with a commercial graphical query builder.
Subjective feedback about Etable was also positive. All par-
ticipants found that Etable was easier to learn and helpful
for exploring databases.

1.

INTRODUCTION

A considerable challenge for non-technical users of rela-
tional databases is constructing join queries [29]. The join
operation is required for even simple data lookup queries
since relational databases store information in multiple sep-
arate normalized tables. Although database normalization
provides many beneÔ¨Åts for managing data (e.g., avoiding
update anomalies), it signiÔ¨Åcantly decreases the usability of
database systems by forcing users to write many join queries
to explore databases.

Constructing join queries is diÔ¨Écult for several reasons.
The main reason is that users Ô¨Ånd it diÔ¨Écult to determine
which relations to join among many relations. Understand-
ing the role of each relation that represents a relationship
of interest and Ô¨Ånding the right join attributes are not triv-
ial tasks, even when a schema diagram is given. To tackle

this challenge, users often write complex queries by starting
with a simpler query and iteratively adding operators [37].
Although this iterative strategy is helpful, it is still chal-
lenging because the format of join query results is hard to
interpret [7]. For example, consider a query that joins two
relations in many-to-many relationships (e.g., Papers and
Authors in Figure 3). A result of this query produces a
large number of duplications (e.g., the title of each paper
repeated as many times as the number of its authors). Peo-
ple represent the same information diÔ¨Äerently when they use
a spreadsheet. For instance, they might create a cell con-
taining multiple values separated by commas. Relational
databases cannot represent data in this way because the re-
lational model (as implemented in most relational DBMSs)
requires that data be at least in the Ô¨Årst normal form.

The usability challenge of writing complex queries has
been studied by many researchers. Although visual query
builders help people formulate SQL queries [14], they sep-
arate query construction and result presentation parts [29],
introducing a usability gap between users‚Äô actions and their
results [42, 37]. To overcome this limitation, researchers
argue that database interfaces need to adopt the direct ma-
nipulation principle [42], popular in the human-computer
interaction area [29, 35]. This principle enables users to
iteratively specify operators by directly interacting with re-
sult instances using simple interactions [35]. Researchers
also argue that join query results should be represented in
an easier-to-understand format that improves the interpre-
tation of query results. Jagadish et al. [30] proposed the
notion of the presentation data model, which they deÔ¨Åned
as a full-Ô¨Çedged layer above the logical and physical schema.
This presentation layer allows users to better understand the
query results without requiring full awareness of the schema.
All this research strongly suggests the need for developing
database interfaces that are usable, interactive, and inter-
pretable.

We present Etable, a novel presentation data model with
which users can interactively browse and navigate databases
on an entity-relationship level without writing SQL. Etable
presents a query result as an enriched table in which each
cell can contain a set of entity references. By deliberately
relaxing the Ô¨Årst normal form, we compactly represent one-
to-many and many-to-many relationships within a single ta-
ble ‚Äî a novel capability that enables users to more easily
browse and interpret query results consisting of multiple re-
lations. Figure 1 illustrates how Etable eÔ¨Äectively presents a
list of SIGMOD papers containing the keyword ‚Äúuser‚Äù from
an academic paper database collected from DBLP and the

1

Figure 1: Etable integrates multiple relations into a single enriched table that helps users browse databases and interactively
specify operators for building complex queries. This example presents a list of SIGMOD papers containing the keyword ‚Äúuser‚Äù
from an academic paper database collected from DBLP and the ACM Digital Library. Each column represents either a base
attribute of a paper or a set of relevant entities obtained from other tables (e.g., Conferences, Authors).
If a relational
database were used to obtain the same information, 9 tables would need to be joined, and the results produced can be hard
to interpret because of many duplicated cells.

ACM Digital Library (see Figure 3 for schema). Each row
in Etable shows the base attributes and relevant entities of
a paper, such as its authors and cited papers. If a relational
database were used to obtain the same information, 9 tables
would need to be joined, and the results produced would be
hard to interpret (e.g., many duplicated cells).

To discover which relevant entities should be shown for
each row, Etable uses a novel graph-based model called the
typed graph model (TGM), which frees users from concern-
ing themselves with the complexity of the logical schema;
users may instead focus on exploring and understanding the
data set at the conceptual (or entity-relationship) level. The
typed graph model stores relational data as graphs in which
nodes represent entities (e.g., authors, papers) and edges
represent relationships (e.g., those that relate authors to pa-
pers). This transformation enables Etable to retrieve other
related entities through simple graph operations. For exam-
ple, a given paper‚Äôs authors, stored as direct neighbors, can
be retrieved through a quick neighbor-lookup.

As the construction of complex queries and the explo-
ration of data are inherently iterative processes, interactive
database exploration tools should provide easy-to-use oper-
ations to help users incrementally revise their queries [17,
37, 35]. Etable‚Äôs direct manipulation interface enables users
to directly work with and modify an existing enriched table
to update its associated queries. For example, suppose our
user Jane starts her exploration with the Papers table (as
in Figure 2, top). She is interested in learning about the
authors of a particular paper, so she clicks on its ‚Äúauthor
count‚Äù button (Figure 2 at 2) to display those authors‚Äô in-
formation. Jane‚Äôs simple interaction of tapping the button
is translated into a series of navigation operators behind the
scene, such as Select, as in selecting the row associated with
a paper; and Add, as in adding and joining the Authors ta-
ble with the Papers table. With a few rounds of similar
interactions, Jane can incrementally build complex queries.
Through Etable, we contribute:
‚Ä¢ A novel presentation data model that presents a
query result as an enriched table for users to easily
browse and explore relational databases (Section 3, 5);

‚Ä¢ A graph-based model, called typed graph model (TGM)

that provides an abstraction of relational databases,
which enables users to explore data in Etable on a con-
ceptual level (Section 4);
‚Ä¢ A set of navigation operators that users iteratively
apply through interacting with an enriched table, al-
lowing complex queries to be constructed incremen-
tally (Section 6);
‚Ä¢ The usable interface of Etable that outperforms a
commercial graphical query builder in a user study,
in both speed and subjective ratings across a range of
database querying tasks (Section 7, 8).

2. RELATED WORK
2.1 Database Usability & Query SpeciÔ¨Åcations

Since Query-by-Example (QBE) was developed in 1970s [48],

database researchers have studied fairly extensively the us-
ability of database systems [29, 13, 2, 28]. Usability is im-
portant, especially because not all database users have ex-
pertise in writing complex queries; many non-technical users
Ô¨Ånd it challenging to write even very simple join queries [29,
1]. Many existing approaches aimed at assisting users with
formulating queries. One representative method is the vi-
sual query builder, which enables users to visually manip-
ulate schema elements on a graphical interface [14]. How-
ever, most visual querying systems require that users have
precise knowledge of a schema, which makes it diÔ¨Écult for
nonexperts to use. This limitation can be relieved in key-
word search systems, studied by many researchers in the last
decade [27, 11, 4, 19]. They allow users to write queries in
natural language text, but these keyword queries cannot pre-
cisely represent users‚Äô needs with attributes. To tackle this
issue, researchers have also developed techniques that gener-
ate SQL for a given text input [33, 23] and tools that provide
users with form-based interfaces [31] with which they ma-
nipulate attributes. However, most of these approaches sep-
arate queries and results so that users cannot reÔ¨Åne queries
by examining results, which decreases the usability of the
systems [37].

2

Papersfiltered¬†by¬†Paper_keywords.keyword¬†like¬†'%user%'¬†AND¬†Conferences.acronym¬†=¬†'sigmod'idÓÑîtitleÓÑîyearÓÑîpage_startÓÑîpage_endÓÑîConferencesacronymÓÑîAuthorsnamesÓÑîPapers¬†(referencing)titlesÓÑîPapers¬†(referenced)titlesÓÑîPaper_keywordskeywordsÓÑî2575Makingdatabasesystems¬†usable20071324SIGMOD7H.¬†V.¬†Jaga‚Ä¶,¬†AdrianeCh‚Ä¶,¬†Aaron¬†Elki‚Ä¶,Magesh¬†Jay‚Ä¶,¬†YunyaoLi12XRANK:¬†Ran‚Ä¶,¬†NaLIX:an‚Ä¶,¬†DaNaLIX:¬†a‚Ä¶,Assisted¬†q‚Ä¶,¬†Towardsa‚Ä¶25QueryViz:‚Ä¶,Exploring‚Ä¶,Efficient‚Ä¶,¬†Homebrewd‚Ä¶,¬†The¬†intera‚Ä¶6user¬†inter‚Ä¶,¬†humanfact‚Ä¶,¬†general¬†,usability¬†,¬†design2628Addressingdiverse¬†userprefer‚Ä¶2007641652SIGMOD2Zhiyuan¬†Ch‚Ä¶,¬†TaoLi10Adaptive¬†w‚Ä¶,¬†Enhancedw‚Ä¶,¬†Context‚Äêse‚Ä¶,Automatic‚Ä¶,¬†Orderingt‚Ä¶13Making¬†dat‚Ä¶,Supporting‚Ä¶,¬†Skimmer:r‚Ä¶,¬†Diversity‚Ä¶,Efficient‚Ä¶5informatio‚Ä¶,¬†userprefe‚Ä¶,¬†data¬†explo‚Ä¶,human¬†fact‚Ä¶,algorithms2701Assistedquerying¬†usinginstan‚Ä¶200711561158SIGMOD2Arnab¬†Nand‚Ä¶,¬†H.¬†V.Jaga‚Ä¶8Predicting‚Ä¶,¬†Theintera‚Ä¶,¬†FreeQ:¬†an‚Ä¶,Efficient‚Ä¶,¬†Location‚Äêa‚Ä¶8query,¬†keyword,interface,autocomple‚Ä¶,¬†userinter‚Ä¶1928SkewTune:mitigatingskew¬†in¬†m‚Ä¶20122536SIGMOD4YongChul¬†K‚Ä¶,Magdalena‚Ä¶,¬†BillHowe,¬†Jerome¬†A.‚Ä¶3A¬†platform‚Ä¶,¬†Alatency‚Ä¶,¬†Highly‚ÄêAva‚Ä¶6Minimal¬†Ma‚Ä¶,SpongeFile‚Ä¶,¬†Shark:SQL‚Ä¶,¬†Fast¬†data‚Ä¶,Effective‚Ä¶9skew,¬†parallel¬†d‚Ä¶,design,¬†query¬†proc‚Ä¶,performanc‚Ä¶1953Towards¬†aunifiedarchitecture‚Ä¶2012325336SIGMOD4Xixuan¬†Fen‚Ä¶,¬†ArunKumar,¬†Benjamin¬†R‚Ä¶,Christophe‚Ä¶4Towards¬†a‚Ä¶,¬†MCDB:¬†amo‚Ä¶,¬†MauveDB:¬†s‚Ä¶,Large‚Äêscal‚Ä¶6Sparkler:‚Ä¶,¬†LearningG‚Ä¶,¬†A¬†performa‚Ä¶,Knowledge‚Ä¶,¬†Shark:SQL‚Ä¶10theory,¬†user‚Äêdefin‚Ä¶,measuremen‚Ä¶,incrementa‚Ä¶,design2326Efficientlyincorporatinguser‚Ä¶200987100SIGMOD4Xiaoyong¬†C‚Ä¶,¬†Ba‚ÄêQuyVuo‚Ä¶,¬†AnHai¬†Doan,Jeffrey¬†F.‚Ä¶7Provenance‚Ä¶,¬†Pay‚Äêas‚Äêyou‚Ä¶,¬†An¬†Interac‚Ä¶,¬†Tosearch‚Ä¶,¬†Interactiv‚Ä¶5Building,‚Ä¶,Automatica‚Ä¶,Integratin‚Ä¶,Provenance‚Ä¶,¬†Deco:decl‚Ä¶8informatio‚Ä¶,¬†userfeedb‚Ä¶,¬†systems¬†,informatio‚Ä¶,¬†design1875Interactivedata¬†miningwith¬†3‚Ä¶201310091012SIGMOD4Elke¬†Achte‚Ä¶,¬†Hans‚ÄêPeter‚Ä¶,¬†Erich¬†Schu‚Ä¶,Arthur¬†Zim‚Ä¶3Efficient‚Ä¶,¬†FindingGe‚Ä¶,¬†Computing‚Ä¶3SigniTrend‚Ä¶,Subsamplin‚Ä¶,Representa‚Ä¶4visualizat‚Ä¶,¬†userinter‚Ä¶,¬†high‚Äêdimen‚Ä¶,parallel¬†c‚Ä¶2688MashMaker:mashups¬†forthe¬†mas‚Ä¶200711161118SIGMOD2Robert¬†Enn‚Ä¶,¬†Minos¬†N.G‚Ä¶3VizDeck:¬†s‚Ä¶,¬†VizDeck:a‚Ä¶,¬†Exploring‚Ä¶3human¬†fact‚Ä¶,¬†end‚Äêusers¬†,¬†design2317Crowds,clouds,¬†andalgorithms‚Ä¶201012591260SIGMOD5Sihem¬†Amer‚Ä¶,¬†AnHaiDoan,¬†Jon¬†M.¬†Kle‚Ä¶,Nick¬†Kouda‚Ä¶,¬†MichaelJ.‚Ä¶2Early¬†onli‚Ä¶,¬†Pay‚Äêas‚Äêyou‚Ä¶2CrowdDB:¬†a‚Ä¶,StreamRec:‚Ä¶16security,experiment‚Ä¶,economics,user/machi‚Ä¶,reliabilit‚Ä¶2219Load‚Äêbalancedquerydisseminat‚Ä¶2010471482SIGMOD4Emiran¬†Cur‚Ä¶,¬†AlinDeuts‚Ä¶,¬†K.¬†K.¬†Rama‚Ä¶,Divesh¬†Sri‚Ä¶3Speeding¬†u‚Ä¶,Distribute‚Ä¶,¬†P‚Äêring:an‚Ä¶1Privacy¬†pr‚Ä¶12online¬†com‚Ä¶,publisher‚Ä¶,¬†loadbalan‚Ä¶,¬†design,¬†usercenso‚Ä¶2675ConEx:¬†a200710761078SIGMODChaitanya‚Ä¶,¬†MaksimsToward¬†a¬†P‚Ä¶,1ParaTimer:‚Ä¶graphical‚Ä¶,¬†design¬†,HISTORY1.¬†Open¬†'Papers'¬†table2.¬†Filter¬†'Papers'¬†table¬†by(Paper_keywords¬†like¬†'%user%')3.¬†Sort¬†table¬†by¬†#¬†of¬†Papers(referenced)4.¬†Filter¬†'Papers'¬†table¬†by(Paper_keywords¬†like¬†'%user%'¬†&Conferences¬†=¬†'sigmod')5.¬†Sort¬†table¬†by¬†#¬†ofPaper_keywords6.¬†Sort¬†table¬†by¬†#¬†of¬†Papers(referenced)ETABLE¬†BUILDERChoose¬†a¬†table2.2

Iterative Querying & Direct Manipulation
Several database researchers argued that the usability of
database querying systems can improve by adopting the di-
rect manipulation paradigm [42, 43], a well-established de-
sign principle in the human-computer interaction (HCI) and
information visualization areas. The HCI community ac-
knowledges that users‚Äô needs are often ambiguous rather
than precisely speciÔ¨Åable, so they design tools with which
users can interact.
In the context of database querying,
Nandi and Jagadish [37] proposed a guided interaction paradigm.
They argued that users‚Äô querying process is often iterative,
so database systems should guide users toward interactively
formulating and reÔ¨Åning queries.

To provide users with usable database interfaces, researchers

have developed many interactive tools. Although they are
not speciÔ¨Åcally designed for relational databases [32, 22, 21,
36], a number of interactive visualization systems for entity-
relationship data have been developed by information visu-
alization researchers. For example, NetLens [32] visualizes
relationships between two selected entity types in many-to-
many relationships.
In addition, GraphTrail [22] visually
summarizes each entity type and enables users to switch be-
tween entities. Although these visualization systems provide
an overview of data sets, they are not suited for examining
database instances along with attributes. In exploring and
analyzing instance-level information, tabular interfaces, in-
cluding spreadsheets, are better suited and often preferred
by database users [24, 46, 35, 10, 25]. Tyszkiewicz [46] ar-
gued that spreadsheets can play a role as a database engine
by using functions and macros. Liu and Jagadish [35] for-
mally deÔ¨Åned operators that interactively perform grouping
operations within a spreadsheet. However, since the rigid
tabular structure does not eÔ¨Äectively present many-to-many
relationships, the spreadsheet suÔ¨Äers from the same prob-
lems that relational databases have:
It produces a large
number of duplications. To overcome this limitation, Ja-
gadish et al. [30] proposed using a presentation view layer
on top of underlying databases, which is the notion of the
presentation data model, deÔ¨Åned as a full-Ô¨Çedged layer on
top of the logical and physical models. The challenge is
to design presentation data models that help people easily
understand join query results and interact with them.
2.3 Data Models for Effective Presentation

To develop an intuitive structure for presentation data
models, we review a number of data models that concep-
tualize the mini-world represented in databases. One such
example is the nested relational model, studied in the 1980s,
which allows each cell to contain another table that presents
one-to-many relationships in a single table [40, 39]. The
nested model has been used in several studies for design-
ing database interfaces. Bakke et al. designed a spread-
sheet interface following the nested structure [7], and Dat-
aPlay [3] also used the nested model for presenting query
results. However, the model suÔ¨Äers from scalability issues
because the sizes of the tables often become huge when an
inner table contains a large number of associated rows or
columns [8]. One way to tackle this problem is to replace the
inner table with a set of pointers. For example, the object-
relational model lets attributes be user-deÔ¨Åned types that
include pointers [44]. We adapt this idea by introducing an
entity reference which compactly represents related entities.
Another class of the data models that eÔ¨Äectively conceptual-

3

Figure 2: Users can iteratively specify operations by inter-
acting with Etable. In this example, users can examine fur-
ther information about paper authors in three ways: (1)
clicking on an author‚Äôs name; (2) clicking a paper‚Äôs author
count; (3) clicking on the pivot button.

ize the real-world is the graph data model [6, 26, 15, 45]. It
represents entities as nodes and relationships as edges based
on the entity-relationship model [18, 9]. Catarci et al., [16]
used a graph-style translation layer for their visual querying
system. To provide users with an easy-to-understand view
at an entity-relationship level, we also maintain a graph-
style model, transformed from relational databases, under
the presentation view.

3.

INTRODUCING ETABLE

Before we describe the technical details of the proposed
data models, we introduce Etable by describing what users
see and how they can interact with it.

Representation. Figure 1 illustrates an enriched ta-
ble that we call Etable. As mentioned earlier, it presents
a list of SIGMOD papers containing the keyword ‚Äúuser‚Äù
from our collected database (see Figure 3 for schema). Each
row of Etable represents a single entity of the selected en-
tity type (i.e., Papers); its column represents either a base
attribute of the entity (e.g., year) or a set of relevant enti-
ties (e.g., authors, keywords). This representation is formed
by pivoting a query result of a join of multiple tables (e.g.,
Papers, Paper keywords, Authors) to a user-selected entity
type (e.g., Papers). One advantage of this representation is
that it can simultaneously present all relevant information
about an entity in a single row (e.g., authors, keywords, ci-

(1) Click reference(2) Click count123(3) Click Pivot buttonForm

Source

Node types Entity tables

Multi-valued attributes
Single-valued categorical attributes Attribute of low cardinality

Determining factor for mapping from a relational table

Relation with a single-attribute primary key
Relation with two attributes; one of them references an entity relation

Edge types One-to-many relationships

Many-to-many relationships
Multi-valued attributes
Single-valued categorical attributes From an entity table to a categorical attribute

Foreign key between two entity relations
Relation with a composite primary key; both reference entity relations
From an entity table to a multi-valued attribute

Table 1: Categories of node and edge types based on how they are translated from relational schema

tations). The relational model cannot represent all of this
information in a single relation without duplications because
an attribute value must be atomic. For instance, when the
Papers table is joined with the Authors table, the paper
information is repeated as many times as the number of
authors, which prevents users from quickly interpreting the
results. We integrate information spread across multiple ta-
bles into a single table by allowing each cell to contain a set
of references to other entities.

Interactions. Users can interact with Etable to explore
further information. For instance, to examine further infor-
mation about the authors of the papers in Figure 1, users
can create a new Etable that lists authors in several ways,
as depicted in Figure 2: (1) If users are interested in one of
the authors (e.g., Arnab Nandi), they can click on his name
to create a new Etable consisting of one row that presents
its attributes; (2) if users want to list the complete set of
authors (e.g., all seven authors of the paper titled ‚ÄúMak-
ing database systems usable‚Äù), they can click on the author
count in the right corner of the cell (i.e., 7); and (3) if users
want to list and sort the entities across the entire rows in
a column (e.g., Who wrote the most papers about ‚Äúuser‚Äù
in SIGMOD?), they can click on the pivot button on the
column menu, which groups and sorts the authors based on
the number of papers they have written. By gradually ap-
plying these operations, users can incrementally make sense
of data and build complex queries. A series of interactions
triggered by users are translated into an internal query form
to be executed.

4. TYPED GRAPH MODEL

In this section, we deÔ¨Åne a typed graph model (TGM)
which enables users to explore relational databases on a
conceptual entity-relationship level without having to know
a logical schema. A relational schema and instances are
translated into a database schema graph and database in-
stance graph as a pre-processing step, and all operations
speciÔ¨Åed by users on the Etable interface are executed over
these graphs, not relational databases.

We represent entities and relationships as a graph with
types and attributes. Each entity becomes a node, and re-
lationships among the entities become edges. A typed graph
database (TGDB) consists of a TGDB schema graph, GS,
and a TGDB instance graph, GI .

DeÔ¨Ånition 1. Schema Graph. A TGDB schema graph
GS is a tuple (T ,P), where T represents a set of node types
(or entity types1), and P ‚äÜ T √ó T represents a set of edge
types (or relationship types). Each node type œÑi ‚àà T is
1We use the words ‚Äúnode‚Äù and ‚Äúentity‚Äù interchangeably.
A node is used more formally; an entity is used more for
presentation to users.

Figure 3: The relational schema of the academic data set
used in this work, 7 relations in total.

Figure 4: TGDB schema graph constructed from the rela-
tional schema in Figure 3. Node types represented as rect-
angles. Edge types represented as lines between node types.

a tuple (Œ±i,Ai, Œ≤i), where Œ±i denotes the name of a node
type, Ai is a set of single-valued attributes, and Œ≤i is a la-
bel attribute chosen from one of the attributes and used
to represent node instances of this type. Each edge type
œÅ ‚àà P also has a name and a set of attributes. We de-
note the source and target node types of œÅ as source(œÅ) and
target(œÅ), respectively. All the edge types, except self loops,
are bidirectional.

DeÔ¨Ånition 2. Instance Graph. A TGDB instance graph,
GI , is a tuple (V, E), where V represents a set of nodes (or
entities) and E represents a set of edges (or relationships)
between two nodes. Every instance graph GI has a corre-
sponding schema graph GS, and the instance graph has a
node type mapping function typeœÑ : V ‚Üí T and an edge
type mapping function typeœÅ : E ‚Üí P that partition nodes
V into V1, ..., VnT and edges E into E1, ..., EnP . Each node
v ‚àà V consists of a set of attribute values v[Aij] for the
attributes of the corresponding node type and has a label
deÔ¨Åned as label(v) = v[Œ≤i]. Each edge e ‚àà E consists of a
set of attribute values e[Aij] for its type. We denote the
source and target nodes of e as source(e) and target(e),
respectively.

4

Paper_Authorspaper_idauthor_idorderAuthorsidnameinstitution_idPapersidconference_idtitleyearpage_startpage_endPaper_Keywordspaper_idkeywordPaper_Referencespaper_idref_paper_idForeign keyPrimary keyConferencesidshorttitleInstitutionsidnamecountryidInstitutionsInstitutions: countryPapersConferencesAuthorsPapers: yearPaper_keywords: keywordThe typed graph model, similar to various graph data
models [6, 26, 45], is much more eÔ¨Äective for conveying a
conceptual understanding of the mini-world represented in
databases than the relational model. As it abstracts rela-
tional databases, users can ignore the logical and physical
representation of data. Users can also easily understand the
structure of data, since nodes always represent entities and
edges represent relationships, Unlike TGM, the relational
model is a mixture of entities, relationships, and multivalued
attributes. Although some existing graph models are more
expressive for representing a variety of relationships (e.g.,
hierarchical parent-child relationships among entities), we
simply use nodes and edges to focus on making the seman-
tics of the underlying relations more explicit by mapping
to entities and relationships that they represent in the real
world.

Relational databases can be translated into the TGDB
schema and instance graphs in a near-automatic process. We
adapt the reverse engineering literature pertaining to trans-
lating relational databases into several graph-style models [9,
20, 41]. A detailed procedure presented in Appendix A in-
cludes an analysis of a relational schema based on primary
keys, foreign keys, and cardinalities for classifying tables
into several categories, and a series of actions that create
the schema graph. Table 1 summarizes the categories of
node and edge types based on how they are determined from
relational schema. Figure 4 illustrates a schema graph con-
structed from a relational schema of an academic publication
database shown in Figure 3.

5. ETABLE PRESENTATION DATA MODEL
We present our Etable presentation data model for usable

exploration of entities and relationships in databases.
5.1 Enriched Table

A query result in the Etable model is presented as an en-
riched table, which we also call Etable. An Etable R has
a set of columns A and consists of a set of rows r ‚àà R.
The columns are categorized into two types: single-attribute
columns Ab and entity-reference columns As. The value of
the single-attribute column r[A] is atomic as it is in the rela-
tional model. The value of the entity-reference column r[A]
contains a single or a set of entity references. The entity ref-
erence refers to another node in the database instance graph.
Unlike a foreign key in the relational model, each entity ref-
erence is shown as a clickable label, similar to a hyperlink on
a webpage. Just like how a hyperlink‚Äôs hypertext describes
the webpage that the link points to (instead of its URL), for
example, Etable represents an author‚Äôs entity reference by
the author name (instead of the author ID).

The entity-reference columns present rich information spread

across multiple relations within a single enriched table. While
a foreign key attribute in the relational model contains only
a single reference for a many-to-one relationship because of
the Ô¨Årst normal form, an entity-reference column can rep-
resent one-to-many relationships, many-to-many relation-
ships, or multivalued attributes in a single column. Further-
more, the entity-reference column has advantages over the
nested relational model which requires much screen space
as it squeezes another table into cells, leading to ineÔ¨Écient
browsing. Unlike the nested model, Etable presents clickable
labels that compactly show information and allow users to
further explore relevant information.

5

5.2 Etable SpeciÔ¨Åcation

An Etable can be speciÔ¨Åed by selecting speciÔ¨Åc elements
of the database schema and instance graphs in the typed
graph model introduced in the previous section.

DeÔ¨Ånition 3. Etable Query SpeciÔ¨Åcation. An Etable

R is speciÔ¨Åed by a query pattern Q, which is a tuple (œÑa, T, P,C).

1. Primary node type œÑa: It is one of the node types in
the schema graph. Each row of Etable will represent a
single node instance of the primary node type.

2. Participating node types T :

It is a set of node
types chosen from the node types in the schema graph,
i.e., T = (t1, ..., tn),‚àÄti ‚àà T . It must contain the pri-
mary node type œÑa, i.e., œÑa ‚àà T .
It determines the
scope of data instances and is similar to a set of re-
lations in SQL FROM clauses. A node type in the
schema graph can exist multiple times in the partici-
pating node types, like a relational algebra expression
can contain the same relation multiple times.

3. Participating edge types P : It is a set of edge types

selected from the schema graph, i.e., P = (p1, ..., pn),‚àÄpi ‚àà
P.
It connects the participating nodes types, thus
the source and target nodes of these edges should ex-
i.e., source(pi) ‚àà
ist in the participating node types.
T ‚àß target(pi) ‚àà T,‚àÄpi ‚àà P.

4. Selection conditions for node types C: It is a set of
selection conditions C = {C1, ..., Cn} applied to each of
the participating node types, i.e., Ci applies to ti ‚àà T .

A query pattern can be represented as an acyclic graph
where one of the nodes are marked as a primary node type
and a node can have selection conditions. For example, the
query pattern at the top of Figure 5 represents a query that
produces a list of researchers who have published papers at
SIGMOD after 2005 and are currently working at institu-
tions in Korea.
5.3 Query Execution

Instance Matching

A query pattern will be executed to create a Ô¨Ånal result in
the Etable format. The execution process is divided into two
steps: instance matching and format transformation. The
Ô¨Årst step extracts matched node instances from the database
instance graph, and the second step transforms a result from
the Ô¨Årst step into the Etable format.
5.3.1
The instance matching process Ô¨Ånds a set of matched in-
stances for a given query pattern. Strictly speaking, it re-
turns a graph relation RG, which consists of a set of tu-
ples, each of which contains a list of node instances in the
database instance graph. The graph relation is generated
with an instance matching function m(Q), which consists of
a series of operations. The operations constitute primitives
which make up a graph relation algebra.

A graph relation RG, similar to a relation in the relational
model, consists of a set of tuples with a set of attributes.
The schema of the graph relation is deÔ¨Åned as a set of node
types A = (A1, ..., An) where Ai ‚àà T . In other words, each
attribute Ai corresponds to a node type. The correspond-
ing node type œÑj determines the domain of the attribute

Figure 5: An example query pattern and its execution process.

(i.e., domaini = {v|v ‚àà Vj}). A base graph relation is de-
Ô¨Åned as a graph relation with a single attribute. In other
words, each node type œÑ1, ..., œÑn produces a base graph rela-
tion R1, ..., Rn. A non-base graph relation can be created by
applying the following graph relation operators to the base
graph relations.

1. Selection. It Ô¨Ålters tuples of a graph relation R using
a selection condition Ci applicable to one of the node
types Ai.

œÉCi (RG) = {r|r ‚àà RG ‚àß r[Ai] satisÔ¨Åes Ci}.

2. Join.

It joins two graph relations R1 and R2 using
edge types œÅk. The attributes of the created graph
relation is a concatenation of the attributes of the two
graph relations.

R1 ‚àóœÅk R2 = {(r1, r2)|r1 ‚àà R1 ‚àß r2 ‚àà R2

‚àß source(œÅk) ‚àà A1 ‚àß target(œÅk) ‚àà A2}.

We use a symbol, ‚àó, to diÔ¨Äerentiate it from the rela-
tional correspondence, (cid:46)(cid:47).

3. Projection.

It removes all attributes of the graph
relations except the given attribute. Duplicated rows
are eliminated.

Œ†Ai (RG) = {r[Ai]|r ‚àà RG}.

These operators enable us to deÔ¨Åne an instance matching
function m(Q). In fact, this function only requires the Se-
lection and Join operators: the Projection operator will be
used later in the format transformation step.

DeÔ¨Ånition 4. Instance Matching. Given a query pat-
tern Q(œÑa, T, P,C), a matching function m returns a graph
relation RG containing node instances in the instance graph
GI .

m(Q) = œÉC1 (R1) ‚àóp1 œÉC2 (R2) ‚àóp2 ... ‚àópn‚àí1 œÉCn (Rn)

(1)

where Ri is a base graph relation obtained from a node type
ti ‚àà T , i.e., Ri = {v|v ‚àà V ‚àß type(v) = ti}, Ci ‚àà C is a
selection condition for Ri, and pi ‚àà P is one of the edge

6

types that joins graph relations on both sides, i.e., pi =
{p|p ‚àà P ‚àß source(p) ‚àà {t1, ...ti} ‚àß target(p) ‚àà {ti+1, ...tn}}.

Figure 5 (left) illustrates the instance matching process.
It returns a graph relation, which is an intermediate format
to be transformed into the Etable format.
5.3.2 Format Transformation
A graph relation obtained from the instance matching
function is transformed into the Etable format. We describe
how rows and columns of Etable are determined from the
instance matching result.

The rows of Etable consist of nodes of the primary node
type, Ô¨Åltered by all selection conditions in the query pattern.
They are extracted from the instance matching result:

R = {v|v ‚àà Œ†œÑa (m(Q(T, P,C)))}.

(2)

Given the result of the instance matching function, all at-
tributes except the attribute representing the primary node
type are discarded, and then, each of distinct node in that
column becomes a row.

Etable has three types of columns to present rich infor-
In addition to the attributes of the
mation for each row.
primary node types, which we call base attributes Ab, we
introduce two other types of columns for presenting a set of
entity references: participating node columns, At, and neigh-
bor node columns, Ah.

1. List of base attributes Ab: It is a full set of the
attributes A of the primary node type œÑa. The value
of the column Aj ‚àà Ab would be a single value:

r[Aj] = v[Aj].

(3)
2. List of participating node types At: It is a set of
all the node types T in the query pattern, except the
primary node type œÑa, i.e., At = {œÑ|œÑ ‚àà T ‚àß œÑ (cid:54)= œÑa}.
The value of the column Aj ‚àà At would be a set of
entity references:

r[Aj] ={u|u ‚àà V ‚àß Aj = type(u)

AuthorsInstitutionscountry like ‚Äò%Korea%‚ÄôConfPape11141518PapersConferencesacronym = ‚ÄòSIGMOD‚ÄôConfPapeAuthInst11131413144314118151318131843idnameInstPapersConf1Bob31,4,5,814Mark34,8111Chad841Conf1PapeAuth11124144411518184Pape134578111317..Auth123456789..Inst34891420212528..AuthInst132133435767728594....year > 2005Query Patternùúéùëéùëêùëüùëúùëõùë¶ùëö=‚Ä≤ùëÜùêºùê∫ùëÄùëÇùê∑‚Ä≤(ùëÖùê∂ùëúùëõùëì) ‚àóùê∂ùëú‚àíùëÉùëéùúéùë¶ùëíùëéùëü>2005(ùëÖùëÉùëéùëùùëíùëüùë†) ‚àóùëÉùëé‚àíùê¥ùë¢ùëÖùê¥ùë¢ùë°‚Ñéùëúùëüùë†‚àóùê¥ùë¢‚àíùêºùëõùúéùëêùëúùë¢ùëõùë°ùëüùë¶ùëôùëñùëòùëí‚Ä≤%ùêæùëúùëüùëíùëé%‚Ä≤(ùëÖùêºùëõùë†ùë°)Query ExecutionInstance matchingFormat transformationAuthorsIntermediate graph relationFinal result in Etableformat3. List of neighbor node types Ah: It is a set of all
the neighboring node types of the primary node type
œÑa in the schema graph regardless of the query pattern,
i.e., Ah = {(œÅ, œÑ )|œÑ ‚àà T ‚àß œÅ ‚àà P ‚àß source(œÅ) = œÑa ‚àß
target(œÅ) = œÑ}. The value of the column Aj ‚àà Ah
would be a set of nodes references:
r[Aj] ={u|u ‚àà V ‚àß e ‚àà E ‚àß Aj = (type(e), type(u))

Figure 5 (right) illustrates the results produced from the
format transformation process. The Ô¨Årst two columns are
base attributes, and the rest of the columns are participating
node columns. We omit neighbor node columns as some
of these columns are the same as the participating node
columns.

By transforming the graph relation into the Etable for-
mat, we compactly present join query results without du-
plications. Each row of Etable is uniquely determined by
a node of a primary node type. The participating node
columns show all the other entity types in the query pattern
with respect to the primary node type. This transformation
process is similar to the GROUP BY operation in SQL, but
while GROUP BY aggregates the corresponding instances
into a single value (i.e., COUNT, AVG), Etable presents a
list of the corresponding instances as entity references. The
neighbor node columns are also useful for describing the
rows of the Etable, although information in these columns is
not obtained from the graph relation. These columns enable
users to browse one-to-many or many-to-many relationships.
Moreover, they provide users with a preview of possible new
join operations as it presents all the join candidates. For in-
stance, Figure 1 consisting of many neighbor node columns
(e.g., Authors) helps users browse rich information about
each paper.

6. NAVIGATION OPERATORS

A query pattern can be interactively modiÔ¨Åed and up-
dated by users. They can change the query pattern by
applying one of the navigation operators below, creating a
new, updated Etable. Formally, given an Etable speciÔ¨Åcation
R(œÑa, T, P,C), each of the following operator creates a new
a, T (cid:48), P (cid:48),C(cid:48)), except the Initiate operator
speciÔ¨Åcation R(cid:48)(œÑ(cid:48)
which creates a new Etable from scratch.

1. Initiation. A new Etable is created when a user se-
lects one of the node types in the schema graph. This
is the only way of creating a new Etable from scratch.

DeÔ¨Ånition 5. Initiate. When a user selects one of
the node types œÑk, the following operation is invoked:

Initiate(œÑk) = R

(cid:48)

where œÑ

(cid:48)
a = œÑk, T

(cid:48)

= {œÑk}, P

(cid:48)

= {}, and C = {}.

2. Selection. Users can Ô¨Ålter rows based on their columns,
similar to the selection operator in the relational model.

DeÔ¨Ånition 6. Selection. When a user induces a se-
a, the

lection condition Ck to the primary node type œÑ i
following is invoked:

Select(C, R) = R

where œÑ

(cid:48)
a = œÑa, T

(cid:48)
(cid:48)

(cid:48)

= T, P

= P, and C

(cid:48)
a = Ck.

7

Figure 6: An example of building a query incrementally by
applying navigation operators.

3. Adding a node type. Users can navigate to another
node type to examine how it is related to the current
primary node type by selecting one of the neighbor
node types. It corresponds to adding a join operator
in the relational model.

DeÔ¨Ånition 7. Add. When a user selects one of the
neighboring node types, a node type linked to the pri-
mary node type œÑa by an edge type œÅk (i.e., source(œÅk) =
œÑa) is added to the participating node types:

Add(œÅk, R) = R

(cid:48)

where œÑ

(cid:48)
a = target(œÅk), T
(cid:48)
P

= P ‚à™ {œÅk}, and C(cid:48)

(cid:48)

= T ‚à™ {target(œÅk)},

= C ‚à™ {}

4. Shifting focus to another participating node type.

Users can navigate back to one of the participating
node types œÑk to see how it is related to the current
primary node type. It can be thought of as represent-
ing the current join result from a diÔ¨Äerent angle.

DeÔ¨Ånition 8. Shift. When a user selects one of the
other participating node type œÑk, the following is in-
voked:

Shif t(œÑk, R) = R

where œÑ

(cid:48)
a = œÑk, T

(cid:48)
(cid:48)

= T, P

(cid:48)

= P, and C(cid:48)

= C

The above primitive navigation operators enable users to
build any complex query patterns by incrementally specify-
ing the operators one-by-one. For instance, users can create
a new query pattern by Initiate; they can keep adding node
types by Add, just like adding relations to FROM clauses
in SQL, and selection conditions by Select, just like writ-
ing expressions in WHERE clauses. They can also change
the representation of the current join result by Shift, similar
to GROUP BY. A sequence of these operators speciÔ¨Åed by

Conferencesacronym = ‚ÄòSIGMOD‚ÄôInitiate(‚ÄúConferences‚Äù)Select(‚Äúacronym = ‚ÄòSIGMOD‚Äô‚Äù)Add(‚ÄúPapers‚Äù)Select(‚Äúyear > 2005‚Äù)Add(‚ÄúAuthors‚Äù)Add(‚ÄúInstitutions‚Äù)Select(‚Äúcountry like ‚Äò%Korea%‚Äô‚Äù)Shift(‚ÄúAuthors‚Äù)ConferencesPapersConferencesacronym = ‚ÄòSIGMOD‚ÄôPapersConferencesacronym = ‚ÄòSIGMOD‚Äôyear > 2005AuthorsPapersConferencesacronym = ‚ÄòSIGMOD‚Äôyear > 2005AuthorsInstitutionsPapersConferencesacronym = ‚ÄòSIGMOD‚Äôyear > 2005AuthorsInstitutionscountry like ‚Äò%Korea%‚ÄôPapersConferencesacronym = ‚ÄòSIGMOD‚Äôyear > 2005AuthorsInstitutionscountry like ‚Äò%Korea%‚ÄôPapersConferencesacronym = ‚ÄòSIGMOD‚Äôyear > 2005Figure 7: The Etable interface consists of (1) the default table list for initiating a query, (2) the main view presenting query
results, (3) the schema view showing a query pattern, and (4) the history view listing operators speciÔ¨Åed by users. Users can
build queries and explore databases by directly interacting with the interface.

users constitutes a query pattern in the Etable model. Fig-
ure 6 shows an example of the query construction process
consisting of 8 operators.

operator if the column is the neighbor node type; it
performs the Shift operator if it is the participating
node type.

7.

INTERFACE & SYSTEM DESIGN

Etable‚Äôs interface (Figure 7) consists of four components:
(1) the default table list, (2) the main view, (3) the schema
view, and (4) the history view. The default table list presents
a list of entity types in the schema graph. Users can pick
one from the list to initiate a query. The main view presents
an Etable executed based on a query pattern which is graph-
ically shown over the schema view. Users can directly inter-
act with the main view to update the current query. The
list of operators speciÔ¨Åed by users is presented on the history
view, which allows users to revert to a previous state.
7.1 User-Level Actions

Users can update the current query pattern by directly
interacting with Etable. We provide the following user-level
actions that invoke the navigation operators we discussed in
the previous section.

1. Initiate. Users can initiate a new query by clicking
a node type œÑk on the default table list. The action
invokes the Initiate(œÑk) operator.

2. Filter. Users can Ô¨Ålter rows of the current Etable
by inducing selection conditions. The Ô¨Ålter window is
popped up when they click the Filter button on the
column menu triggered by clicking the small arrow (‚à®)
in the right corner of each column header. This action
performs the Select operator. In addition to the base
attributes, users can also Ô¨Ålter rows by the labels of the
neighbor nodes columns (e.g., authors‚Äô names), which
is translated into subqueries. We currently provide
only a conjunction of predicates, but it is straightfor-
ward to provide disjunctions and more operations.

3. Pivot. Users can change the primary node type by
clicking the pivot button on the column menu for neigh-
bor or participating node columns.
It calls the Add

4. See a particular node. When users are interested in
one of the entity references, they can click it to create
a new Etable consisting of a single row presenting the
clicked entity. Unlike the above operators, it is an
encapsulation of two navigation operators. It initiates
a new Etable, and then perform the Select operator to
show the single node. For the clicked node vk:

Single(vk, R) =Select(C, type(vk), Init(type(vk)),

where C = {u|u = vk}.

5. See all related nodes. When users are interested in
a full list of entity references, they can click a num-
ber in the right corner of a cell. It also encapsulates
two navigation operators. The operators invoked are
diÔ¨Äerent depending on whether the selected column is
neighbor or participating node column. For the neigh-
boring node column œÅl of vk:

Seeallh(vk, œÅl, R) =Add(œÅl, Select(C, type(vk), R)),

where C = {u|u = vk},

and for the participating node column tl:

Seeallt(vk, tl, R) =Shif t(tl, Select(C, type(vk), R)), R)),

where C = {u|u = vk}}.

We additionally provide some useful operators (e.g., sorting,
column projections) for users, although they are not part of
the primitive navigation operators.
7.2 Architecture

Etable system uses a three-tier architecture, consisting of
(1) an interactive user interface front-end that can run in any
modern web browsers, written in HTML, JavaScript, and
D3.js [12]; (2) a Python-based application server; and (3) a
PostgreSQL database backend. The PostgreSQL database

8

1234Task

1. Find the year that the paper titled ‚ÄòMaking database systems usable‚Äô was published in.
2. Find all the keywords of the paper titled ‚ÄòCollaborative Ô¨Åltering with temporal dynamics‚Äô.
3. Find all the papers that were written by ‚ÄòSamuel Madden‚Äô and published in 2013 or after.
4. Find all the papers written by researchers at ‚ÄòCarnegie Mellon University‚Äô and published

at the KDD conference.

5. Which institution in South Korea has the largest number of researchers?
6. Find the top 3 researchers who have published the most papers in the SIGMOD conference.

Category #Relations

Attribute
Attribute

Filter
Filter

Aggregate
Aggregate

1
2
3
5

2
4

Table 2: List of tasks. Task 1 & 2 retrieve attribute values, task 3 & 4 Ô¨Ålter entities, task 5 & 6 perform aggregations.

stores TGDB schema and instance graphs in four relational
tables: nodes, edges, node types, and edge types. A query
pattern for Etable is translated into a SQL query that oper-
ates on the PostgreSQL database.

8. EVALUATION: USER STUDY

To evaluate the usability of Etable, we conducted a user
study that tests whether users can construct queries quickly
and accurately. We compared Etable with Navicat,2 one of
the most popular commercial database administration tools
with a graphical query building feature. Graphical builders
such as Navicat have been commonly used as baseline sys-
tems in database usability research [35, 38].
8.1 Experimental Design

Participants. We recruited 12 participants from our uni-
versity through advertisements posted to mailing lists at our
institution. All were graduate students who had taken at
least one database course or had industry experience using
database systems. The participants rated their experience
in SQL, averaging at a score of 4.67 using a 7-point Likert
scale (ranged from 3 to 6) with 1 being ‚Äúhaving no knowl-
edge‚Äù and 7 being ‚Äúexpert‚Äù, which means most participants
considered themselves non-expert database users. None of
them had used the graphical query builder before. Each
participant was compensated with a $15 gift card.

Data set. We used an academic publication data set used
throughout this paper, which we collected from DBLP3 and
ACM Digital Library.4 It contains about 38,000 papers from
19 top conferences in the areas of databases (e.g., SIGMOD),
data mining (e.g,. KDD), and human-computer interaction
(e.g., CHI), since 2000. A relational schema was designed
using standard to design principles, resulting in 7 relations
with 7 foreign keys as depicted in Figure 3. As the main
focus of this evaluation is on Etable‚Äôs usability, this data set
creates a suÔ¨Éciently large and complex database for such
purpose.

Procedure. Our study followed a within-subjects design
with two conditions: the Etable condition and the Navi-
cat condition. Every participant Ô¨Årst completed six tasks
in one condition and then completed another six tasks in
the remaining condition. The orders of the conditions were
counterbalanced, resulting in 6 participants in each order-
ing. We generated two matched sets of tasks (6 tasks in
each set) diÔ¨Äered only in their speciÔ¨Åc values used for pa-
rameters such as the title of the paper. Before the partici-
pants were given the tasks to carry out for each condition,
they went through a 10-minute tutorial for the tool they

2http://www.navicat.com/
3http://dblp.uni-trier.de/
4http://dl.acm.org/

Figure 8: Average task completion time for each task. The
error bars represent 95% conÔ¨Ådence intervals for the mean.
Participants using Etable were faster than Navicat. The ‚àó
and ‚ó¶ symbols indicate 99% and 90% statistical signiÔ¨Åcance
in the two-tailed paired t-tests, respectively.

would use. For each task, the participants could ask clarify-
ing questions before starting, and they have a maximum of
5 minutes to complete each task. After the study, they com-
pleted a questionnaire for subjective ratings and qualitative
feedback. Each study lasted for about 70 minutes. Partici-
pants completed the study using Chrome browser, running
on a Windows desktop machine, with a 24-inch monitor at
a 1920x1200 resolution.

Tasks. We carefully generated two matched sets of 6
tasks that cover many database exploration and querying
tasks. Table 2 shows one set (as the other set is similar).
The tasks fall into three categories: Ô¨Ånding attribute values
(Tasks 1 & 2); Ô¨Åltering (Tasks 3 & 4); aggregation (Tasks
5 & 6). The tasks were designed based on prior research
studies and their categorization of tasks. SpeciÔ¨Åcally, our
categories are based on those used in database and human-
computer interaction research [5, 34], and our tasks vary in
diÔ¨Éculty as in [33].

Measurements. We measured participants‚Äô task com-
pletion times.
If a participant failed to complete a task
within 5 minutes, the experimenter stopped the participant
and recorded 300 seconds as the task completion time. Af-
ter completing tasks for both conditions, the participants
Ô¨Ålled out a post-questionnaire that asked for their subjec-
tive ratings about Etable (10 questions) and their subjective
preference between two conditions (7 questions).
8.2 Results

Task completion times. The average task times for
Etable were faster than those for Navicat for all six tasks.
Figure 8 summarizes the task time results. We performed
two-tailed paired t-tests. The diÔ¨Äerences were statistically
signiÔ¨Åcant for Tasks 1, 3, 5, and 6 (p < 0.005) and marginally
signiÔ¨Åcant for Tasks 2 and 4 (p = 0.052, p = 0.053, re-
spectively). The results of Task 2 may be explained by an
outlier participant who did not understand the requirement
that each row of the Ô¨Ånal results should represent a diÔ¨Äer-

9

34.9 39.5 57.2 150.5 59.0 104.8 53.2 54.4 92.3 218.5 231.6 198.5 050100150200250300Task 1*Task 2¬∞Task 3*Task 4¬∞Task 5*Task 6*Time (sec)Average Task Completion Time (sec)EtableNavicatQuestion

1. Easy to learn
2. Easy to use
3. Helpful to locate and Ô¨Ånd speciÔ¨Åc data
4. Helpful to browse data stored in databases
5. Helpful to interpret and understand results
6. Helpful to know what type of information exists
7. Helpful to perform complex tasks
8. Felt conÔ¨Ådent when using Etable
9. Enjoyed using Etable
10. Would like to use software like Etable in the future

Avg.

6.42
6.33
6.25
6.67
5.58
6.00
6.00
5.92
6.42
6.50

Table 3: Subjective ratings about Etable using 7-point Lik-
ert scales (7: Strongly Agreed. 1: Strongly Disagreed ).

ent keyword. Although Task 4 involves the highest num-
ber of operations that require participants to spend signiÔ¨Å-
cant time in interpreting intermediate results before apply-
ing the next operators, Etable helped participants complete
this task faster than Navicat.

The task completion times for Etable generally have low
variance. The larger variance in Navicat is mainly due to
syntax errors that the participants faced. Many partici-
pants, who are non-database experts, could not recall some
SQL syntax and had trouble debugging errors.
In partic-
ular, they had trouble specifying GROUP BY queries in
Navicat. For example, many participants did not specify a
GROUP BY attribute in their SELECT clauses in their Ô¨Årst
attempts. We also observed that many Navicat participants
were overwhelmed by the complexity of the syntax of join
queries [29] and preferred to specify new SQL queries from
scratch instead of debugging existing ones when their orig-
inal queries failed. Unlike graphical query builders such as
Navicat, Etable helps nonexperts gradually build complex
queries without having to know the exact query syntax.

Subjective ratings. We asked participants to rate var-
ious aspects of Etable using 7-point Likert scales (7 being
‚Äústrongly agreed‚Äù). Their subjective ratings were generally
very positive (see Table 3).
In particular, almost all par-
ticipants (11/12) found Etable easy to use and helpful for
browsing data in databases (i.e., rated 6 or 7). They also
enjoyed using Etable (10/12) and would like to use software
like Etable in the future (11/12). In response to the ‚Äúhelpful
to interpret and understand results‚Äù question, one partic-
ipant commented that ‚Äúthere are too many attributes ...,
which is not easy to interpret.‚Äù To address this, as future
work, we plan to develop techniques to rank and select the
most important columns to show when a table has a large
number of columns [47].

We also asked participants to compare Etable and Navicat
in 7 aspects. All participants indicated that Etable was eas-
ier to learn and was more helpful in browsing and exploring
data. A majority of participants liked Etable more (11/12)
and found it easier to use (10/12). They would choose to use
Etable in the future (10/12) and felt more conÔ¨Ådent using
it (8/12). Half of the participants answered that Etable is
more helpful in Ô¨Ånding speciÔ¨Åc data than Navicat. This re-
sult was expected because Etable‚Äôs innovation focuses more
on supporting data exploration.

Qualitative feedback. We asked participants about the
features they liked about Etable. Many participants (9/12)
explicitly mentioned the ‚Äúpivot‚Äù feature. They said that the
pivot feature enabled them to easily specify complex join
queries. One participant said ‚ÄúI also loved the pivot feature
... having multiple pivots throughout the course of forming

a query. I messed up a query, but could still Ô¨Ånd the right
answer by doing an appropriate pivot.‚Äù In addition, many
participants said that Etable provides an intuitive view to
users. One said ‚ÄúIt is easy to see data from the perspective of
what the users want to see/retrieve ...‚Äù Another said ‚ÄúVisu-
ally, I was able to see ... the eÔ¨Äects of the SQL operations,
which made it easier to use and verify intermediate results.‚Äù

9. DISCUSSION: EXPRESSIVE POWER

This section brieÔ¨Çy discusses the expressiveness and the
utility of the Etable data model. A query for Etable, which
operates on TGDB, is equivalent in expressive power to a
relational algebra expression or a single block SQL query.
A graph relation obtained from the instance matching step
can be expressed as a relational algebra expression with pro-
jections, selections, and joins of the following form:

Œ†œÑa (œÉC(R (cid:46)(cid:47) R (cid:46)(cid:47) ... (cid:46)(cid:47) R)),

Note that the mapping of the user actions to underlying re-
lational tables depends on how TGDB schema and instance
graphs are obtained from relational databases. For example,
edge types obtained from many-to-many relationships diÔ¨Äer
from those that originate from many-to-one relationships.
The user is unaware of the schema and instance graphs
and achieves the desired result by letting the system work
through the Etable and TGM mappings.

We can express the overall functionality of the user‚Äôs in-

teractions as the following general SQL query pattern:

SELECT œÑa.*, ent-list(t1), ent-list(t2), ...
FROM t1, t2, ...
WHERE source(p1) = target(p1) AND source(p2) =
target(p2) AND ... AND C1 AND C2 AND ...

GROUP BY œÑa;

where ent-list presents a list of corresponding entity ref-
erences, similar to json agg operator in PostgreSQL.5 Each
of the components in a query pattern maps to each clause in
SQL: node types to FROM clause; edge types to join condi-
tions; selection conditions to WHERE clause; primary node
type to GROUP BY clause.

We can say that any select-project-join queries (i.e., re-
lational algebra expression that do not contain set opera-
tions) that involve joins only through FK-PK relationships
can be translated into a query pattern using the models and
the operators we presented in this paper. Etable addition-
ally lets users choose a primary node type from the list of
selected relations to transform the graph relation into the
Etable format. We do not claim that Etable can express any
relational algebra expression. However, it can express the
core relational algebra (i.e., join, selection, and projection)
and a single block SQL query that involves GROUP BY
of a primary key for one of relations, which accounts for a
large number of the database workloads. This paper focuses
on the critical usability challenge that arises when joining
several tables. To increase the expressiveness of the presen-
tation model, future work could involve additional operators
to support more complex queries (e.g., set operations, com-
plex aggregations).

5http://www.postgresql.org/docs/9.4/static/functions-
aggregate.html

10

10. CONCLUSIONS

We proposed Etable, a new presentation data model for
interactively exploring relational databases. The enriched
table representation of Etable generates a holistic, interac-
tive view of databases that helps users browse relevant in-
formation at an entity-relationship level. By directly inter-
acting with the interface, users can iteratively specify oper-
ators, enabling them to incrementally build complex queries
and navigate databases. Etable outperformed a commercial
graphical query builder in a user study, in both speed and
subjective ratings across a range of database querying tasks.
This work takes a Ô¨Årst step towards developing a prac-
tically usable, interactive interface for relational databases,
and opens up many interesting oppportunities. Future re-
search directions include: (1) incorporating more operators
to further improve expressive power (e.g., complex aggre-
gations); (2) accelerating the execution speed of updated
queries by reusing intermediate results; (3) leveraging ma-
chine learning techniques to rank and select important columns
to display. The above ideas could usher a new generation
of interactive database exploration tools that will beneÔ¨Åt all
database users.

11. ACKNOWLEDGMENTS

This material is based upon work supported by the Na-
tional Science Foundation Graduate Research Fellowship Pro-
gram under Grant No. DGE-1148903.

12. REFERENCES
[1] D. Abadi, R. Agrawal, A. Ailamaki, M. Balazinska, P. A.
Bernstein, M. J. Carey, S. Chaudhuri, J. Dean, A. Doan,
M. J. Franklin, et al. The beckman report on database
research. ACM SIGMOD Record, 43(3):61‚Äì70, 2014.

[2] S. Abiteboul, R. Agrawal, P. Bernstein, M. Carey, S. Ceri,

B. Croft, D. DeWitt, M. Franklin, H. G. Molina,
D. Gawlick, et al. The lowell database research
self-assessment. CACM, 48(5):111‚Äì118, 2005.

[3] A. Abouzied, J. Hellerstein, and A. Silberschatz. Dataplay:

interactive tweaking and example-driven correction of
graphical database queries. In UIST, pages 207‚Äì218. ACM,
2012.

[4] S. Agrawal, S. Chaudhuri, and G. Das. Dbxplorer: A

system for keyword-based search over relational databases.
In ICDE, pages 5‚Äì16. IEEE, 2002.

[5] R. Amar, J. Eagan, and J. Stasko. Low-level components of

analytic activity in information visualization. In IEEE
INFOVIS, pages 111‚Äì117. IEEE, 2005.

[6] R. Angles and C. Gutierrez. Survey of graph database

models. ACM Computing Surveys, 40(1):1, 2008.

[7] E. Bakke, D. Karger, and R. Miller. A spreadsheet-based

user interface for managing plural relationships in
structured data. In CHI, pages 2541‚Äì2550. ACM, 2011.

[8] E. Bakke, D. R. Karger, and R. C. Miller. Automatic

layout of structured hierarchical reports. IEEE TVCG,
19(12):2586‚Äì2595, 2013.

[9] C. Batini, S. Ceri, and S. B. Navathe. Conceptual Database

Design: An Entity-Relationship Approach. Benjamin
Cummings, 1992.

[10] M. Bendre, B. Sun, D. Zhang, X. Zhou, K. C.-C. Chang,

and A. Parameswaran. Dataspread: unifying databases and
spreadsheets. PVLDB, 8(12):2000‚Äì2003, 2015.

[11] G. Bhalotia, A. Hulgeri, C. Nakhe, S. Chakrabarti, and

S. Sudarshan. Keyword searching and browsing in
databases using banks. In ICDE, pages 431‚Äì440. IEEE,
2002.

[12] M. Bostock, V. Ogievetsky, and J. Heer. D3 data-driven

documents. IEEE TVCG, 17(12):2301‚Äì2309, 2011.

11

[13] T. Catarci. What happened when database researchers met

usability. Information Systems, 25(3):177‚Äì212, 2000.

[14] T. Catarci, M. F. Costabile, S. Levialdi, and C. Batini.

Visual query systems for databases: A survey. Journal of
Visual Languages & Computing, 8(2):215‚Äì260, 1997.

[15] T. Catarci, G. Santucci, and M. Angelaccio. Fundamental

graphical primitives for visual query languages.
Information Systems, 18(2):75‚Äì98, 1993.

[16] T. Catarci, G. Santucci, and J. CardiÔ¨Ä. Graphical

interaction with heterogeneous databases. The VLDB
journal, 6(2):97‚Äì120, 1997.

[17] U. Cetintemel, M. Cherniack, J. DeBrabant, Y. Diao,

K. Dimitriadou, A. Kalinin, O. Papaemmanouil, and S. B.
Zdonik. Query steering for interactive data exploration. In
CIDR, 2013.

[18] P. P.-S. Chen. The entity-relationship model: toward a

uniÔ¨Åed view of data. ACM TODS, 1(1):9‚Äì36, 1976.

[19] Y. Chen, W. Wang, Z. Liu, and X. Lin. Keyword search on

structured and semi-structured data. In SIGMOD, pages
1005‚Äì1010. ACM, 2009.

[20] R. H. Chiang, T. M. Barron, and V. C. Storey. Reverse
engineering of relational databases: Extraction of an eer
model from a relational database. Data & Knowledge
Engineering, 12(2):107‚Äì142, 1994.

[21] M. Dork, N. H. Riche, G. Ramos, and S. Dumais.

Pivotpaths: Strolling through faceted information spaces.
IEEE TVCG, 18(12):2709‚Äì2718, 2012.

[22] C. Dunne, N. Henry Riche, B. Lee, R. Metoyer, and

G. Robertson. Graphtrail: Analyzing large multivariate,
heterogeneous networks while supporting exploration
history. In CHI, pages 1663‚Äì1672. ACM, 2012.

[23] J. Fan, G. Li, and L. Zhou. Interactive sql query

suggestion: Making databases user-friendly. In ICDE, pages
351‚Äì362. IEEE, 2011.

[24] S. Few. Show me the numbers: Designing tables and graphs

to enlighten. Analytics Press Oakland, CA, 2004.

[25] H. Gonzalez, A. Y. Halevy, C. S. Jensen, A. Langen,

J. Madhavan, R. Shapley, W. Shen, and J. Goldberg-Kidon.
Google fusion tables: web-centered data management and
collaboration. In SIGMOD, pages 1061‚Äì1066. ACM, 2010.
[26] M. Gyssens, J. Paredaens, J. Van den Bussche, and D. V.

Gucht. A graph-oriented object database model. IEEE
TKDE, 6(4):572‚Äì586, 1994.

[27] V. Hristidis and Y. Papakonstantinou. Discover: Keyword

search in relational databases. In VLDB, pages 670‚Äì681,
2002.

[28] S. Idreos, O. Papaemmanouil, and S. Chaudhuri. Overview

of data exploration techniques. In SIGMOD, pages
277‚Äì281. ACM, 2015.

[29] H. Jagadish, A. Chapman, A. Elkiss, M. Jayapandian,
Y. Li, A. Nandi, and C. Yu. Making database systems
usable. In SIGMOD, pages 13‚Äì24. ACM, 2007.

[30] H. Jagadish, A. Nandi, and L. Qian. Organic databases. In
Databases in Networked Information Systems, pages 49‚Äì63.
Springer, 2011.

[31] M. Jayapandian and H. Jagadish. Automated creation of a

forms-based database query interface. PVLDB,
1(1):695‚Äì709, 2008.

[32] H. Kang, C. Plaisant, B. Lee, and B. B. Bederson. Netlens:

iterative exploration of content-actor network data.
Information Visualization, 6(1):18‚Äì31, 2007.

[33] F. Li and H. Jagadish. Constructing an interactive natural

language interface for relational databases. PVLDB,
8(1):73‚Äì84, 2014.

[34] F. Li, T. Pan, and H. V. Jagadish. Schema-free sql. In

SIGMOD, pages 1051‚Äì1062. ACM, 2014.

[35] B. Liu and H. Jagadish. A spreadsheet algebra for a direct

data manipulation query interface. In ICDE, pages
417‚Äì428. IEEE, 2009.

[36] Z. Liu, S. B. Navathe, and J. T. Stasko. Network-based

visual analysis of tabular data. In IEEE Conf. Visual
Analytics Science & Technology, pages 41‚Äì50. IEEE, 2011.

[37] A. Nandi and H. Jagadish. Guided interaction: Rethinking
the query-result paradigm. PVLDB, 4(12):1466‚Äì1469, 2011.

[38] A. Nandi, L. Jiang, and M. Mandel. Gestural query

speciÔ¨Åcation. PVLDB, 7(4):289‚Äì300, 2013.

[39] M. A. Roth, H. F. Korth, and A. Silberschatz. Extended

algebra and calculus for nested relational databases. ACM
TODS, 13(4):389‚Äì417, 1988.

[40] H.-J. Schek and M. H. Scholl. The relational model with

relation-valued attributes. Information systems,
11(2):137‚Äì147, 1986.

[41] J. F. Sequeda, M. Arenas, and D. P. Miranker. On directly

mapping relational databases to rdf and owl. In WWW,
pages 649‚Äì658. ACM, 2012.

[42] B. Shneiderman. Direct manipulation: A step beyond

programming languages. IEEE Computer, 16:57‚Äì69, 1983.
[43] B. Shneiderman. Direct manipulation for comprehensible,
predictable and controllable user interfaces. In IUI, pages
33‚Äì39. ACM, 1997.

[44] M. Stonebraker and D. Moore. Object Relational DBMSs:
The Next Great Wave. Morgan Kaufmann Publishers Inc.,
1995.

[45] Y. Sun and J. Han. Mining heterogeneous information

networks: principles and methodologies. Synthesis Lectures
on Data Mining & Knowledge Discovery, 3(2):1‚Äì159, 2012.
[46] J. Tyszkiewicz. Spreadsheet as a relational database engine.

In SIGMOD, pages 195‚Äì206. ACM, 2010.

[47] X. Yang, C. M. Procopiuc, and D. Srivastava. Summarizing

relational databases. PVLDB, 2(1):634‚Äì645, 2009.

[48] M. M. Zloof. Query-by-example: A data base language.

IBM Systems Journal, 16(4):324‚Äì343, 1977.

APPENDIX
A. DATABASE TRANSLATION

This section describes a procedure for translating rela-
tional databases into database schema and instance graphs
in the typed graph model. Our approach is based on the
reverse engineering literature [9, 20, 16, 41]. We note that
the following process cannot be applied to any relational
schema, as relational schema cannot contain all the seman-
tics, but is a guideline for translations. We make several
assumptions as in the literature [16, 9]. First, all the re-
lations are in BCNF or 3NF. Second, there are no ternary
relationships: all the relationships are binary. Third, for
relationship relations, we assume that all attributes are for-
eign keys of the relations that participate in the relationship.
Any attributes of the relationship itself are ignored. Finally,
a relation representing multivalued attribute always consists
of two columns.
Identifying entity relations. This step identiÔ¨Åes entity
relations from a set of relations.
Informally, entity rela-
tions refer to relations constructed from entity types in the
entity-relation model. We deÔ¨Åne an entity relation as a rela-
tion whose primary key does not contain a foreign key or a
key inclusion dependent on any other attribute in any other
relation [16, 9]. For each of the identiÔ¨Åed entity relations,
we perform the following process.

1. A relation becomes a node type in the schema graph.
2. The relation name becomes the name of the node type.
3. All the attributes of the relation become the attributes

of the node type.

4. One attribute selected by users becomes a label at-

tribute for the node type.

The label attribute is determined by users. Although we
have tried several heuristics to make this process automatic
(e.g., choosing an attribute with textual data type, high

cardinality, whose names contain certain terms, like name,
title), the process could not be fully automated; we prefer
that users specify labels.
Identifying 1:1 and 1:n relationships. We use foreign
keys, used to represent one-to-one and one-to-many rela-
tionships between entity relations in the relational model, to
identify relationships between entity relations found above.
For each foreign key, we perform the following process.

1. Each foreign key becomes an edge type in the schema
graph. The source node would be a node type repre-
senting a relation containing the foreign key. The tar-
get node would be a node type representing a relation
which the foreign key refers to.

2. Unless the source and target node types are the same,
the edge types are duplicated with a reverse direction.
3. The label is deÔ¨Åned as the name of the target node type.
If the label is used by another edge type, a slightly
diÔ¨Äerent label will be created.

Identifying many-to-many relationships. Many-to-many
relationships are represented as a separate relationship ta-
ble in the relational model. We identify these tables whose
primary key is a concatenation of primary keys of two other
entity relations. For each of the identiÔ¨Åed relationship rela-
tions, we perform the following process.

1. Each relationship relation becomes an edge type in the
schema graph. The two other associated entity rela-
tions become source and target nodes.

2. The remaining two steps are the same as above (i.e.,

Steps 2 and 3)

Identifying multivalued attributes. The relational model
stores multivalued attributes in separate relations. We iden-
tify such relations. We assume these relations consist of only
two attributes where both attributes constitute primary key
and the Ô¨Årst attribute is a foreign key to an entity relation.
For each of this case, we perform the following process.

1. The second attribute becomes a node type in the schema

graph.

2. The node type has one attribute which refers to itself.

The label column is this only attribute.

3. An edge types is also created from the node type rep-
resenting the entity relation to the newly created node
type. It will be duplicated in a reverse direction.

Identifying categorical attributes. This step is optional,
but we Ô¨Ånd this step useful. People often perform GROUP
BY operations over categorical attributes, and this step helps
them perform such analysis. Any of the attributes of the en-
tity relations could be selected by users. Often, attributes
with low cardinality (e.g., less than 30) can be assumed to
be categorical attributes. For each of the selected attributes,
we performe the following process.

1. Each attribute becomes a node type in the schema

graph.

2. It has one attribute which refers to itself. The label

column is this only attribute.

3. An edge types is also created from the node type rep-
resenting the relation to the newly created node type.
It will be duplicated in a reverse direction.

This creates a TGDB schema graph. Under the assump-
tions we made, the schema graph contains all the informa-
tion in the original relational schema. Once the schema is
translated, it is straightforward to create the corresponding
TGDB instance graph.

12


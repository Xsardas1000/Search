Von Neumann Algebras form a Model for the
Quantum Lambda Calculusâˆ—
Kenta Cho and Abraham Westerbaan

Institute for Computing and Information Sciences
Radboud University, Nijmegen, the Netherlands
{K.Cho,awesterb}@cs.ru.nl

Abstract

We present a model of Selinger and Valironâ€™s quantum lambda calculus based on von Neumann
algebras, and show that the model is adequate with respect to the operational semantics.

1998 ACM Subject Classiï¬cation F.3.2 Semantics of Programming Language

Keywords and phrases quantum lambda calculus, von Neumann algebras

1

Introduction

In 1925, Heisenberg realised, pondering upon the problem of the spectral lines of the hydrogen
atom, that a physical quantity such as the x-position of an electron orbiting a proton is
best described not by a real number but by an inï¬nite array of complex numbers [12].
Soon afterwards, Born and Jordan noted that these arrays should be multiplied as matrices
are [3]. Of course, multiplying such inï¬nite matrices may lead to mathematically dubious
situations, which spurred von Neumann to replace the inï¬nite matrices by operators on a
Hilbert space [44]. He organised these into rings of operators [25], now called von Neumann
algebras, and thereby set oï¬€ an explosion of research (also into related structures such as
Jordan algebras [13], orthomodular lattices [2], Câˆ—-algebras [34], AW âˆ—-algebras [17], order
unit spaces [14], Hilbert Câˆ—-modules [28], operator spaces [31], eï¬€ect algebras [8], . . . ), which
continues even to this day.

One current line of research (with old roots [6, 7, 9, 19]) is the study of von Neumann
algebras from a categorical perspective (see e.g. [4, 5, 30]). One example relevant to this
paper is Kornellâ€™s proof that the opposite of the category vNAMIU of von Neumann algebras
with the obvious structure preserving maps (i.e. the unital normal âˆ—-homomorphisms) is
monoidal closed when endowed with the spatial tensor product [18]. He argues that vNAop
MIU
should be thought of as the quantum version of Set. We would like to focus instead on the
category of von Neumann algebras and completely positive normal subunital maps, vNACPsU,
as it seems more appropriate for modelling quantum computation: the full subcategory
of vNAop
CPsU consisting of ï¬nite dimensional von Neumann algebras is equivalent to Selingerâ€™s
category Q [35], which is used to model ï¬rst order quantum programming languages.

On the syntactic side, in 2005, Selinger and Valiron [36,37]
proposed a typed1 lambda calculus for quantum computation,
and they studied it in a series of papers [38â€“40]. A striking
feature of this quantum lambda calculus is that functions

B

âŠ¥ C

âŠ¥

D

Figure 1 General shape of

a model of the QLC

âˆ— The research leading to these results has received funding from the European Research Council under
the European Unionâ€™s Seventh Framework Programme (FP7/2007-2013) / ERC grant agreement no
320571

1 An untyped quantum lambda calculus had already been proposed by Van Tonder [43].

Â© Kenta Cho and Abraham Westerbaan;
licensed under Creative Commons License CC-BY

Leibniz International Proceedings in Informatics
Schloss Dagstuhl â€“ Leibniz-Zentrum fÃ¼r Informatik, Dagstuhl Publishing, Germany

6
1
0
2

 
r
a

M
7

 

 
 
]

O
L
.
s
c
[
 
 

1
v
3
3
1
2
0

.

3
0
6
1
:
v
i
X
r
a

%
%
%
%
d
d
d
d
2

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

naturally appear as data in the description of the Deutchâ€“Jozsa algorithm, teleportation
algorithm and Bellâ€™s experiment. Although Selinger and Valiron gave a precise formulation
of what might constitute a model of the quantum lambda calculus â€” basically a pair of
adjunctions, see Figure 1, with some additional properties [40, Â§1.6] â€” the existence of such
a model (other than the term model) was an open problem for several years until Malherbe
constructed a model in his thesis using presheaves [21]. The construction of Malherbeâ€™s
model is quite abstract, and it is (perhaps because of this) not yet known whether his model
is adequate with respect to the operational semantics deï¬ned by Selinger and Valiron in
[37] (see also [40]). While several adequate models for variations on the quantum lambda
calculus have been proposed in the meantime (using the geometry of interaction in [10], and
quantitative semantics in [27]), Malherbeâ€™s model remains the only model of the original
quantum lambda calculus [37] known in the literature, and so the existence of an adequate
model for the quantum lambda calculus is still open.

In this paper, we present the model of Selinger
and Valironâ€™s quantum lambda calculus, based
on von Neumann algebras, see Figure 2, and we
show that the model is adequate with respect
to the operational semantics. We should note
that it is possible to extend the quantum lambda
calculus with recursion and inductive types, but
that we have not yet been able to include these features in our model.

â€˜âˆ
âŠ¥ vNAop
MIU
nsp

Neumann algebras

Set

âŠ¥

vNAop

CPsU

Figure 2 A model of the QLC using von

The paper is divided in six sections. We begin with a short review of quantum computation
(in Section 2), and the quantum lambda calculus and its operational semantics (in Section 3).
We give the denotational semantics for the quantum lambda calculus using von Neumann
algebras and prove its adequacy in Section 4. For this we use several technical results about
the categories vNAMIU and vNACPsU of von Neumann algebras, which we will discuss in
Section 5. We end with a conclusion in Section 6.

2 Quantum Computation

In a nutshell, one gets the quantum lambda calculus by taking the simply typed lambda
calculus with products and coproducts and adding a qubit type. This single ingredient
dramatically changes the ï¬‚avour of the whole system e.g. forcing one to make the type system
linear, so we will spend some words on the behaviour of qubits in this section. For more
details on quantum computation, see [26].

A state of an isolated qubit is a vector |Ïˆi of length 1 in the Hilbert space C2, and can
be written as a complex linear combination (â€œsuperpositionâ€) |Ïˆi = Î±|0i + Î²|1i, since the
vectors |0i = (1, 0) and |1i = (0, 1) form an orthonormal basis for C2.

When qubits are combined to form a larger system, one can sometimes no longer speak
about the state of the individual qubits, but only of the state of the whole system (in which
case the qubits are â€œentangledâ€). The state of a register of n qubits is a vector |Ïˆi of length 1
in the n-fold tensor product (C2)âŠ—n âˆ¼= C2n, which has as an orthonormal basis the vectors of
the form |wi â‰¡ |w1i âŠ— Â·Â·Â· âŠ— |wni where w â‰¡ w1 Â·Â·Â· wn âˆˆ 2n.

For the purposes of this paper there are three basic operations on registers of qubits.

1. One can add a new qubit in state |0i to a register of n qubits in state |Ïˆi, turning it to a

register of n + 1 qubits in state |Ïˆi âŠ— |0i. A qubit in state |1i can be added similarly.

2. One can apply a unitary 2n Ã— 2n matrix U to a register of n qubits in state |Ïˆi turning

the state to U|Ïˆi.

*
*
%

+
+
h
h
l
l
K. Cho and A. Westerbaan

3

3. One can test the ï¬rst qubit in the register. If the state of the register is written as
|Ïˆi â‰¡ Î±|0i âŠ— |Ïˆ0i + Î² |1i âŠ— |Ïˆ1i where the length of |Ïˆ0i and |Ïˆ1i is 1, then the test
comes out negative and changes the state of the register to |0iâŠ—|Ïˆ0i with probability |Î±|2,
and comes out positive with probability |Î²|2 changing the state to |1i âŠ— |Ïˆ1i.
Measurement of the i-th qubit in the register is also possible and behaves similarly.

A predicate on a register of n qubits is a 2n Ã— 2n matrix P such that both P and I âˆ’ P are
positive (which is the case when P is a projection). The probability that P holds in state |Ïˆi
is hÏˆ|P|Ïˆi. For example, given a state |Ïˆi of a qubit, the projection |ÏˆihÏˆ| (which maps |Î¾i
to hÏˆ|Î¾i|Ïˆi) represents the predicate â€œthe qubit is in state |Ïˆiâ€.

Thus the predicates on a qubit are part of the algebra M2 of 2Ã—2 complex matrices. There
is also an algebra for the bit, namely C2. A predicate on a bit is an element (x, y) â‰¡ v âˆˆ C2
with 0 â‰¤ v â‰¤ 1, which is interpreted as â€œthe bit is true with probability y, false with
probability x, and undeï¬ned with probability 1 âˆ’ x âˆ’ yâ€.

An operation on a register of qubits may not only be described by the eï¬€ect it has on

states (SchrÃ¶dingerâ€™s view), but also by its action on predicates (Heisenbergâ€™s view).
1. The operation which takes a bit b and returns a qubit in state |bi is represented by the

3. The operation which tests a qubit and returns the outcome is represented by the

2. The operation which applies a unitary U to a register of n qubits is represented by the

map fnew : M2 â†’ C2 given by fnew(A) = (h0|A|0i, h1|A|1i ).
map fU : M2n â†’ M2n given by fU(A) = Uâˆ—AU.
map fmeas : C2 â†’ M2 given by fmeas(Î», ) = Î»|0ih0| + |1ih1|.
Ln
A general operation between ï¬nite dimensional quantum data types is usually taken to be
a completely positive subunital linear map (see below) between direct sums of matrix algebras,
i=1 Mmi. The category formed by these operations is equivalent to Qop [4, Th. 8.4].
Von Neumann algebras are a generalisation of direct sums of matrix algebras to inï¬nite
dimensions. Formally, a von Neumann algebra A is a linear subspace of the bounded
operators on a Hilbert space H , which contains the identity operator, 1, is closed under
multiplication, involution, (âˆ’)âˆ—, and is closed in the weak operator topology, i.e. the topology
generated by the seminorms |hx|âˆ’|xi| where x âˆˆ H (cf. [16,25]).

We believe that the opposite vNAop

CPsU of the category of von Neumann algebras and
normal completely positive subunital maps (deï¬nitions are given below) might turn out
to be the most suitable extension of Q to describe operations between (possibly inï¬nite
dimensional) quantum data types. Indeed, to support this thesis, we will show that vNAop
CPsU
gives a model of the quantum lambda calculus.

Let us end this section with the deï¬nitions that are necessary to understand vNACPsU.
An element a of a von Neumann algebra A is self-adjoint if aâˆ— = a, and positive if a â‰¡ bâˆ—b
for some b âˆˆ A . The self-adjoint elements of a von Neumann algebra A are partially
ordered by: a â‰¤ b iï¬€ bâˆ’ a is positive. Any upwards directed bounded subset D of self-adjoint

elements of a von Neumann algebra A has a supremumW D in the set of self-adjoint elements

of A [16, Lem. 5.1.4]. (So a von Neumann algebra resembles a domain.)

The linear maps between von Neumann algebras which preserve the multiplication,
involution, (âˆ’)âˆ—, and unit, 1, are called unital âˆ—-homomorphisms in the literature and MIU-
maps by us. A linear map f between von Neumann algebras is positive if it maps positive
elements to positive elements, unital if it preserves the unit, subunital if f(1) â‰¤ 1, and normal
if f is positive and preserves suprema of bounded directed sets of self-adjoint elements. (If
subunital maps are akin to partial maps between sets, then the unital maps are the total

4

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

Type A, B ::= qbit | > | !A | A (cid:40) B | A âŠ— B | A âŠ• B
Term M, N, L ::= xA | newA | measA | U A | Î»nxA.M | M N | âˆ—n | let hxA, yBin = N in M
A,B(N) | match L withn(xA 7â†’ M | yB 7â†’ N)
A,B(W )

Value V, W ::= xA | newA | measA | U A | âˆ—n | Î»nxA.M | hV, Win | inln
Table 1 Types, terms and values of the quantum lambda calculus

A,B(V ) | inrn

| hM, Nin | inln

A,B(M) | inrn

maps. Normality is the incarnation of Scott continuity in this setting, and coincides with
continuity with respect to the Ïƒ-weak = ultraweak = weak* topology [32, Th. 1.13.2].)
Given a von Neumann algebra A on a Hilbert space H , and a von Neumann algebra B
on a Hilbert space K , the spatial tensor product A âŠ—B of A and B is the least von Neumann
algebra on H âŠ— K which contains all operators of the form a âŠ— b where (a âŠ— b)(x âŠ— y) =
a(x)âŠ— b(y) for all a âˆˆ A , b âˆˆ B, x âˆˆ H and y âˆˆ K [15, Â§11.2]. (The tensor product A âŠ— B
may be physically interpreted as the composition of the systems A and B â€” recall that a
register of two qubits is represented by the von Neumann algebra M2 âŠ— M2.)
Given normal positive f : A â†’ B and g : C â†’ D there might be a normal positive linear
map f âŠ— g : A âŠ— C â†’ B âŠ— D given by (f âŠ— g)(a âŠ— c) = f(a) âŠ— g(c). An interesting, and
annoying, phenomenon is that such f âŠ— g need not exist for all f and g. This warrants
the following deï¬nition: if f : A â†’ B is a positive linear map such that for every natural
number n the map Mn(f): Mn(A ) â†’ Mn(B) is positive, then f is called completely
positive [29]. Here Mn(A ) is the von Neumann algebra of n Ã— n matrices with entries drawn
from A , and Mn(f)(A)ij = f(Aij) for all i, j and A âˆˆ Mn(A ). If f and g are normal and
completely positive, then f âŠ— g exists, and is completely positive [41, Prop. IV/5.13].

The Quantum Lambda Calculus and its Operational Semantics

3
We review the quantum lambda calculus for which we will give a denotational semantics.
The language and its operational semantics are basically the same as Selinger and Valironâ€™s
ones [37], but with sum type âŠ• [40] and â€˜indexedâ€™ terms [38], see Remark 1 and Notation 2
below. For space reasons we omit many details, and refer to [37,38,40].

3.1 Syntax and Typing Rules
The language consists of types, terms and values deï¬ned in Table 1. We use obvious shorthand
!nA = !Â·Â·Â· !A and AâŠ—n = A âŠ— Â·Â·Â· âŠ— A. The subtyping relation <: on types is deï¬ned by the
rules shown in Table 2(a). In the deï¬nition of terms and values, n âˆˆ N is a natural number;
x ranges over variables; and U ranges over 2k Ã— 2k unitary matrices for k â‰¥ 1. The (nullary)
constructors new, meas, U are called constants and sometimes referred to by c. Clearly, values
form a subclass of terms. As usual, we identify terms up to Î±-equivalence.
(cid:73) Remark 1. The terms are indexed terms of [38], which have explicit type annotations (cf.
Church-style vs. Curry-style in the simply-typed lambda calculus). A typing derivation for
an indexed term is unique in a suitable sense, so that we can more easily obtain Lemma 12.
In fact, for the language of [38] we can safely remove the type annotations [38, Corollary 1].
We conjecture that the same is true for our language, which is left as a future work.
(cid:73) Notation 2. Following [40] (and [10, 27]), the language has sum type âŠ• instead of
the bit type (which exists in [37]). The bit type and its constructors are emulated by
bit := > âŠ• >; ffn := inln>,>(âˆ—n); ttn := inrn>,>(âˆ—n); and if L then M else N :=
match L with0(x> 7â†’ M | y> 7â†’ N), with fresh variables x, y.

K. Cho and A. Westerbaan

5

!nqbit <: !mqbit

!n> <: !m>

A1 <: B1

A2 <: B2

!n(A1 âŠ— A2) <: !m(B1 âŠ— B2)

A1 <: B1

A2 <: B2

!n(A2 (cid:40) B1) <: !m(A1 (cid:40) B2)
A1 <: B1

A2 <: B2

!n(A1 âŠ• A2) <: !m(B1 âŠ• B2)

(a) Rules for subtyping, with a condition (n = 0 â‡’ m = 0) for each rule

âˆ†, x : A, y : B, Î“ (cid:66) M : C (ex)
âˆ†, y : B, x : A, Î“ (cid:66) M : C
âˆ†, x : A (cid:66) M : B

((cid:40).I1)

âˆ† (cid:66) Î»0xA.M : A (cid:40) B

A <: B

âˆ†, x : A (cid:66) xB : B
Î“, !âˆ†, x : A (cid:66) M : B

(ax1 )

!Ac <: B (ax2 )
âˆ† (cid:66) cB : B
FV(M) âˆ© |Î“| = âˆ…

Î“, !âˆ† (cid:66) Î»n+1xA.M : !n+1(A (cid:40) B)

((cid:40).I2)

!âˆ†, Î“1 (cid:66) M : A (cid:40) B

!âˆ†, Î“2 (cid:66) N : A ((cid:40).E)

!âˆ†, Î“1, Î“2 (cid:66) M N : B
!âˆ†, Î“1 (cid:66) M : !nA

(>)

âˆ† (cid:66) âˆ—n : !n>
!âˆ†, Î“1, x : !nA, y : !nB (cid:66) M : C

!âˆ†, Î“1, Î“2 (cid:66) hM, Nin : !n(A âŠ— B)
!âˆ†, Î“2 (cid:66) N : !n(A âŠ— B)

!âˆ†, Î“1, Î“2 (cid:66) let hxA, yBin = N in M : C

(âŠ—.E)

!âˆ†, Î“2 (cid:66) N : !nB (âŠ—.I)

âˆ† (cid:66) M : !nA
A,B(M) : !n(A âŠ• B)

âˆ† (cid:66) inln

(âŠ•.I1)

âˆ† (cid:66) N : !nB
A,B(N) : !n(A âŠ• B)

âˆ† (cid:66) inrn

(âŠ•.I2)

!âˆ†, Î“1, x : !nA (cid:66) M : C

!âˆ†, Î“1, y : !nB (cid:66) N : C

!âˆ†, Î“2 (cid:66) L : !n(A âŠ• B)

!âˆ†, Î“1, Î“2 (cid:66) match L withn(xA 7â†’ M | yB 7â†’ N) : C

(âŠ•.E)

(b) Typing rules

Table 2 Subtyping relation and typing rules

The set FV(M) of free variables is deï¬ned in the usual way. A context is a list âˆ† = x1 :
A1, . . . , xn : An of variables xi and types Ai where the variables xi are distinct. We write
|âˆ†| = {x1, . . . , xn} and !âˆ† = x1 : !A1, . . . , xn : !An. We also write âˆ†|M = âˆ† âˆ© FV(M) for
the context restricted to the free variables of M.
A typing judgement, written as âˆ† (cid:66) M : A, consists of a context âˆ†, a term M and a type
A. A typing judgement is valid if it can be derived by the typing rules shown in Table 2(b).
In the rule (ax2 ), c ranges over new, meas and 2k Ã— 2k unitary matrices U; and the types Ac
are deï¬ned as follows: Anew = bit (cid:40) qbit, Ameas = qbit (cid:40) !bit, AU = qbitâŠ—k (cid:40) qbitâŠ—k.
The type system is aï¬ƒne (weak linear). Each variable may occur at most once, unless it

has a duplicable type !A. Substitution of the following form is admissible.
(cid:73) Lemma 3 (Substitution). If !âˆ†, Î“1, x : A (cid:66) M : B and !âˆ†, Î“2 (cid:66) V : A, where V is a value
and |Î“1| âˆ© |Î“2| = âˆ…, then !âˆ†, Î“1, Î“2 (cid:66) M[V /x] : B.
(cid:74)
Note, however, that we need to deï¬ne the substitution M[V /x] with care. For example,
if A <: A0, M = yA0(cid:40)BxA0 and V = zA, then we substitute zA0 (not zA) for xA0 in M.
See [38, Â§2.5] or [42, Â§9.1.4] for details.

3.2 Operational Semantics
The operational semantics is taken from [37,40], but is adapted for indexed terms.
(cid:73) Deï¬nition 4. A quantum closure is a triple [|Ïˆi, Î¨, M ] with m âˆˆ N where:

|Ïˆi is a normalised vector of the Hilbert space (C2)âŠ—m âˆ¼= C2m.

0

0
N ]
, M
0i, Î¨0
,hM

[ |Ïˆi, Î¨, M N ] â†’p [ |Ïˆ
0i, Î¨0
, Nin ]
[ |Ïˆi, Î¨,hM, Nin ] â†’p [ |Ïˆ
[ |Ïˆi, Î¨, let hxA, yBin = M in N ] â†’p [ |Ïˆ
[ |Ïˆi, Î¨, inln
[ |Ïˆi, Î¨, inrn
[ |Ïˆi, Î¨, match M withn(xA 7â†’ N | yB 7â†’ L) ] â†’p [ |Ïˆ

A,B(M) ] â†’p [ |Ïˆ
A,B(M) ] â†’p [ |Ïˆ

0i, Î¨0
0) ]
0) ]

A,B(M
A,B(M

, inln
, inrn

0i, Î¨0
0i, Î¨0

[ |Ïˆi, Î¨, V M ] â†’p [ |Ïˆ

0i, Î¨0

0 ]
, V M
[ |Ïˆi, Î¨,hV, Min ] â†’p [ |Ïˆ
0i, Î¨0
, let hxA, yBin = M
0 in N ]

,hV, M

0in ]

6

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

xA.M)V ] â†’1 [ |Ïˆi, Î¨, M[V /x] ]

[ |Ïˆi, Î¨, (Î»
0
[ |Ïˆi, Î¨, let hxA, yBin = hV, Win in M ] â†’1 [ |Ïˆi, Î¨, M[V /x, W/y] ]
[ |Ïˆi, Î¨, match inln
[ |Ïˆi, Î¨, match inrn

A,B(V ) withn(xA 7â†’ M | yB 7â†’ N) ] â†’1 [ |Ïˆi, Î¨, M[V /x] ]
A,B(W ) withn(xA 7â†’ M | yB 7â†’ N) ] â†’1 [ |Ïˆi, Î¨, N[W/y] ]

(a) Classical control

k

1

, . . . , xqbit

i0 ] â†’1 [ |Ïˆ

[ |Ïˆi, Î¨, U qbitâŠ—k(cid:40)qbitâŠ—khxqbit
[ |Ïˆi,|x1 . . . xmi, measqbit(cid:40)!nbit xqbit
[ |Ïˆi,|x1 . . . xmi, measqbit(cid:40)!nbit xqbit
[ |Ïˆi,|x1 . . . xmi, newA(cid:40)qbit Ëœff ] â†’1 [ |Ïˆi|0i,|x1 . . . xmyi, yqbit ]
[ |Ïˆi,|x1 . . . xmi, newA(cid:40)qbit Ëœtt ] â†’1 [ |Ïˆi|1i,|x1 . . . xmyi, yqbit ]

] â†’p0 [ |Ïˆ0i,|x1 . . . xmi, ffn ]
] â†’p1 [ |Ïˆ1i,|x1 . . . xmi, ttn ]

0i, Î¨,hxqbit

1

i

i

, . . . , xqbit

k

i0 ]

((cid:40))
(âŠ—)
(âŠ•1)
(âŠ•2)

(U)
(meas0)
(meas1)
(new0)
(new1)

(b) Quantum data
If [ |Ïˆi, Î¨, M ] â†’p [ |Ïˆ0i, Î¨0, M0 ], the following are valid reductions (if well-formed).

0i, Î¨0

, match M

0 withn(xA 7â†’ N | yB 7â†’ L) ]

(c) Congruence rules

Table 3 Reduction rules

Î¨ is a list of m distinct variables, written as |x1 . . . xmi. We write |Î¨| = {x1, . . . , xm},
and Î¨(xi) = i for the position of a variable in the list.
M is a term with FV(M) âŠ† |Î¨|.

We say a quantum closure P = [|Ïˆi,|x1 . . . xmi, M ] is well-typed of type A, written as P : A,
if the typing judgement x1 : qbit, . . . , xm : qbit (cid:66) M : A is valid. We call [|Ïˆi, Î¨, V ] a
value closure if V is a value.

(cid:73) Deï¬nition 5. A (small-step) reduction P â†’p Q consists of quantum closures P, Q and
p âˆˆ [0, 1], meaning that P reduces to Q with probability p. The valid reductions P â†’p Q
are given inductively by the reduction rules shown in Table 3. In the rules, V and W refer
to values. The â€˜quantum dataâ€™ rules (b) correspond to the three basic operations explained
in Â§2. In the rule (U), |Ïˆ0i is the state obtained by applying the 2k Ã— 2k unitary matrix U to
the k qubits of the position Î¨(x1), . . . , Î¨(xk) in |Ïˆi. In the rule (meas0), p0 is the probability
that we obtain 0 (â€˜negativeâ€™ in terms of Â§2) by measuring the i-th qubit of |Ïˆi; and |Ïˆ0i is
the state after that. The rule (meas1) is similar. In the rule (new0), we denote by Ëœff any
term of the form inln!k>,!h>(âˆ—n+k) (cf. Notation 2). The term Ëœtt in (new1) is similar.

Reduction satisï¬es the following properties.

(cid:73) Lemma 6 (Subject reduction). If P : A and P â†’p Q, then Q : A.
(cid:74)
(cid:73) Lemma 7 (Progress). Let P : A be a well-typed quantum closure. Then either P is a value
closure, or there exists a quantum closure Q such that P â†’p Q. In the latter case, there are

K. Cho and A. Westerbaan

7

at most two (up to Î±-equivalence) single-step reductions from P, and the total probability of
(cid:74)
all the single-step reductions from P is 1.

The next deï¬nitions follow [37,39].

(cid:73) Deï¬nition 8. We deï¬ne the small-step reduction probability prob(P, Q) âˆˆ [0, 1] for well-
typed quantum closures P, Q by: prob(P, Q) = p if P â†’p Q; prob(V, V ) = 1 if V is a value
closure; prob(P, Q) = 0 otherwise. Lemma 7 guarantees that prob is a probabilistic system in
a suitable sense. For a well-typed quantum closure P and a well-typed value closure Z, the big-
step reduction probability Prob(P, Z) âˆˆ [0, 1] is deï¬ned by Prob(P, Z) = limnâ†’âˆ probn(P, Z),

where prob1(P, Z) = prob(P, Z) and probn+1(P, Z) =P

Q prob(P, Q) probn(Q, Z).

(cid:73) Deï¬nition 9. For each b âˆˆ {ff0
the set of well-typed quantum closures of the form [|Ïˆi, Î¨, b ].

, tt0}, we deï¬ne P â‡“ b =P

ZâˆˆUb

Prob(P, Z), where Ub is

We will use a strong normalisation result. The proof is similar to [27, Lemma 33].

(cid:73) Lemma 10 (Strong normalisation). Let P : A be a well-typed quantum closure. Then there
is no inï¬nite sequence of reductions P â†’p1 P1 â†’p2 P2 â†’p3 Â·Â·Â· .
Proof (Sketch). Clearly it suï¬ƒces to prove the strong normalisation for the underlying (non-
deterministic) reductions M â†’ N on terms. We add a constant cqbit to replace free variables
xqbit. We then deï¬ne a translation (âˆ’)â€  from the quantum lambda calculus (with cqbit) to a
simply-typed lambda calculus with product, unit, sum types and constants new, meas, U, cqbit.
The translation (âˆ’)â€  forgets the ! modality, and translates the let constructor via (let hx, yi =
N in M)â€  = (Î»z.(Î»x.Î»y.Mâ€ ) fst(z) snd(z))Nâ€ . We can prove the strong normalisation for
(cid:74)
the simply-typed lambda calculus via standard techniques.

4 Denotational Semantics Using von Neumann Algebras
4.1 Facts about von Neumann Algebras
We need the following notation and facts concerning von Neumann algebras. Those facts for
which we could not ï¬nd proof in the literature will be discussed in the next section.
Let (vNAMIU,âŠ—, C) be the symmetric monoidal category (SMC) of von Neumann algebras
and normal MIU-maps [18, Prop. 7.2], and (vNACPsU,âŠ—, C) the SMC of von Neumann
algebras and normal CPsU-maps (where âŠ— is the spatial tensor product) [4]. Note that the
unit C is initial in vNAMIU (but not in vNACPsU). Both categories have products given by
direct sums âŠ• (with the supremum norm [41, Def. 3.4]). To interpret the quantum lambda
calculus, we will use the following pair of (lax) symmetric monoidal adjunctions,

(Setop

,Ã—, 1)

nsp
âŠ¥
â€˜âˆ

(vNAMIU,âŠ—, C)

F
âŠ¥
J

(vNACPsU,âŠ—, C)

(1)

where Setop is the opposite of the category Set of sets and functions, considered as a SMC
via cartesian products (i.e. coproducts in Setop). The functor J is the inclusion functor; the
other functors are explained in the next section. Note that J is strict symmetric monoidal
and strictly preserves products. The following facts are important:

vNAMIU is a co-closed SMC [18]. This means the endofunctor (âˆ’) âŠ— A on vNAMIU
has a left adjoint (âˆ’)âˆ—A . The von Neumann algebra Bâˆ—A is called the free exponential
in [18].

0
0
q
q

|
0
0
q
q
8

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

B fâˆ’â†’ C âŠ— A in vNACPsU
FB âˆ’â†’ C âŠ— A in vNAMIU

The counit of the adjunction nsp a â€˜âˆ is an isomorphism (see Corollary 21).
The functors nsp, â€˜âˆ and the adjunction nsp a â€˜âˆ are strong monoidal (see Corollary 23).
Moreover, the functors nsp and â€˜âˆ preserves products (see Cor. 20 and Lem. 22).
The tensor product âŠ— distributes over products âŠ• in vNAMIU, as A âŠ— (B âŠ• C ) âˆ¼=
(A âŠ— B)âŠ• (A âŠ— C ), since A âŠ— (âˆ’) is a right adjoint and thus preserves products. We denote
the canonical isomorphism by Î¸A ,B,C : (A âŠ— B) âŠ• (A âŠ— C ) â†’ A âŠ— (B âŠ• C ).
We deï¬ne a â€˜Kleisli co-exponentialâ€™ (cid:40) by
A (cid:40) B := (FB)âˆ—A . We have the bijective
correspondence as shown on the right. We
write Î›f = g for the MIU-map A (cid:40) B â†’ C
(FB)âˆ—A = A (cid:40) B gâˆ’â†’ C in vNAMIU
corresponding to f. We also write ÎµA ,B =
Î›âˆ’1id: B â†’ (A (cid:40) B) âŠ— A for the co-evaluation map, i.e. the CPsU-map correspond-
ing to id: A (cid:40) B â†’ A (cid:40) B. Then (Î›f âŠ— id) â—¦ Îµ = f by the naturality of the bijective
correspondence.
We write L = â€˜âˆ â—¦ nsp for the strong symmetric monoidal monad on vNAMIU induced
by the left-hand adjunction of (1). The unit and multiplication are denoted by Î· and Âµ
respectively. From the fact that the counit of nsp a â€˜âˆ is an isomorphism, it easily follows
that L is an idempotent monad, i.e. the multiplication Âµ: L2 â‡’ L is an isomorphism. Note
also that L preserves products. We denote the structure isomorphisms by: dLC : C â†’ LC;
A ,B : LA âŠ— LB â†’ L(A âŠ— B); and eL
dL
Because the adjunction nsp a â€˜âˆ satisï¬es a dual condition to a linear-non-linear model [1]
(see also [23,33]), the monad L has a property which is dual to a linear exponential comonad.
Thus each object of the form LA is equipped with a map (cid:79)A : LA âŠ— LA â†’ LA which,
with a unique map !LA : C â†’ LA , makes LA into a âŠ—-monoid in vNAMIU.
(cid:73) Remark 11. One can summarise these facts by saying that the opposite vNAop
MIU is a
(weak) linear category for duplication [38,40]; and moreover vNAop
MIU is a concrete model
of the quantum lambda calculus deï¬ned by Selinger and Valiron [40, Â§1.6.8]. Although they
gave the deï¬nition of concrete models of the quantum lambda calculus, results on them (e.g.
how to interpret the quantum lambda calculus; adequacy of models) have never been given.
In the remainder of the section, therefore, we will give the interpretation of the language in
von Neumann algebras concretely, and then prove its adequacy.

A ,B : LA âŠ• LB â†’ L(A âŠ• B).

4.2 The Interpretation of Types and Typing Judgements
We interpret types as von Neumann algebras, i.e. objects in vNAMIU / vNACPsU, as follows.

(cid:74)!A(cid:75) = L(cid:74)A(cid:75)
(cid:74)A âŠ• B(cid:75) =(cid:74)A(cid:75) âŠ•(cid:74)B(cid:75)

(cid:74)qbit(cid:75) = M2
(cid:74)A (cid:40) B(cid:75) =(cid:74)A(cid:75) (cid:40)(cid:74)B(cid:75)
(cid:73) Remark. One familiar with Fock space might be surprised to realise that(cid:74)!qbit(cid:75) = {0},

because there is no normal MIU-map Ï•: M2 â†’ C. The intuition here may be that no part of
a qubit can be duplicated, and so the assumption of a duplicable qubit amounts to nothing.
This is also the interpretation of !qbit intended by Selinger and Valiron, see [38, Â§5].
(cid:73) Remark. The interpretation of a function type A (cid:40) B is obtained by abstract means,
and at this point we know very little about it. (Might it be as intangible as an ultraï¬lter?)
However, applying ! makes the function type almost trivial: after Â§4, it will be clear that

(cid:74)>(cid:75) = C

(cid:74)A âŠ— B(cid:75) =(cid:74)A(cid:75) âŠ—(cid:74)B(cid:75)

(cid:74)!(A (cid:40) B)(cid:75) = â€˜âˆ({ f :(cid:74)B(cid:75) CPsUâˆ’â†’ (cid:74)A(cid:75)}).

K. Cho and A. Westerbaan

9

given in Â§2, as follows.

map dL

C â—¦ LÎ›(fmeas â—¦ Î·âˆ’1

in vNAMIU, which exists uniquely by a coherence property for an idempotent (co)monad;

C2 ):(cid:74)!Ameas(cid:75) = L(M2 (cid:40) LC2) âˆ’â†’ C

C â—¦ LÎ›fnew :(cid:74)!Anew(cid:75) = L(C2 (cid:40) M2) âˆ’â†’ C
C â—¦ LÎ›fU :(cid:74)!AU(cid:75) = L(MâŠ—k2 (cid:40) MâŠ—k2 ) âˆ’â†’ C

treat the monoidal structure (âŠ—, C) as if it were strict monoidal, which is justiï¬ed by the
coherence theorem for monoidal categories.
fnew : M2 â†’ C2, fmeas : C2 â†’ M2 and fU : MâŠ—k2 â†’ MâŠ—k2

The interpretation of the subtyping relation A <: B is a â€˜canonicalâ€™ map (cid:74)B(cid:75) â†’(cid:74)A(cid:75)
see [42, Â§8.3.2] for details. For instance, we have(cid:74)A (cid:40) !B <: !A (cid:40) !!B(cid:75) = Î·(cid:74)A(cid:75) (cid:40) Âµ(cid:74)B(cid:75).
Contexts âˆ† = x1 : A1, . . . , xn : An are interpreted as(cid:74)âˆ†(cid:75) =(cid:74)A1(cid:75) âŠ— Â·Â·Â· âŠ—(cid:74)An(cid:75). We shall
The interpretations (cid:74)new(cid:75), (cid:74)meas(cid:75) and (cid:74)U(cid:75) of constants are deï¬ned using the maps
(cid:74)new(cid:75) = Î·âˆ’1
(cid:74)meas(cid:75) = Î·âˆ’1
(cid:74)U(cid:75) = Î·âˆ’1
We now give the interpretation(cid:74)âˆ† (cid:66) M : A(cid:75) of a typing judgement as a map(cid:74)A(cid:75) â†’
(cid:74)âˆ†(cid:75) in vNACPsU. The deï¬nition is similar to [11]. First we deï¬ne a normal CPsU-map
(cid:74)âˆ† (cid:66) M : A(cid:75)FV :(cid:74)A(cid:75) â†’ (cid:74)âˆ†|M(cid:75) (recall that âˆ†|M = âˆ† âˆ© FV(M)) by induction on the
derivation of the typing judgement as shown in Table 4. We then deï¬ne(cid:74)âˆ† (cid:66) M : A(cid:75) :=
((cid:74)A(cid:75) (cid:74)âˆ†(cid:66)M:A(cid:75)FV
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’(cid:74)âˆ†|M(cid:75) Î¹âˆ’â†’(cid:74)âˆ†(cid:75)). Here and in Table 4, we use the following notations (often
contexts âˆ† âŠ† Î“, we write Î¹:(cid:74)âˆ†(cid:75) â†’(cid:74)Î“(cid:75) for the â€˜injectionâ€™ map deï¬ned via unique MIU-maps
!A : C â†’ A . For a context !âˆ†, Î“1, Î“2, we deï¬ne the map merge:(cid:74)!âˆ†, Î“1(cid:75) âŠ—(cid:74)!âˆ†, Î“2(cid:75) â†’
(cid:74)!âˆ†, Î“1, Î“2(cid:75) via monoid structures (cid:79)(cid:74)A(cid:75) :(cid:74)!A(cid:75) âŠ—(cid:74)!A(cid:75) â†’(cid:74)!A(cid:75) and symmetry maps Î³. The
âˆ† :(cid:74)!âˆ†(cid:75) â†’ L(cid:74)âˆ†(cid:75) can be deï¬ned using dL
A ,B : LA âŠ— LB â†’ L(A âŠ— B). We write
Âµâˆ† :(cid:74)!!âˆ†(cid:75) â†’(cid:74)!âˆ†(cid:75) for Âµ(cid:74)A1(cid:75)âŠ—Â·Â·Â·âŠ—Âµ(cid:74)An(cid:75); dLn : LnA âŠ—LnB â†’ Ln(A âŠ—B) for Lnâˆ’1
dLâ—¦Â·Â·Â·â—¦dL;
and eLn : LnA âŠ•LnB â†’ Ln(A âŠ• B) similarly. Projection maps and tupling for direct sums,
products in vNACPsU, are denoted by Ï€i : A1 âŠ• A2 â†’ Ai and hf, gi: A â†’ B âŠ• C .
Note that the interpretation(cid:74)âˆ† (cid:66) M : A(cid:75) is deï¬ned by induction on typing derivations.

suppressing subscripts). Let Î³A ,B : A âŠ— B â†’ BâŠ— A denote the symmetry isomorphism. For

Because we use indexed terms, it is not hard to prove the following fact by induction on a
typing derivation Î .
(cid:73) Lemma 12. Suppose that âˆ† (cid:66) M : A is valid with a derivation Î , and so is âˆ†0 (cid:66) M : A

with Î 0. Then(cid:74)Î 0(cid:75)FV = Ïƒ â—¦(cid:74)Î (cid:75)FV, where Ïƒ :(cid:74)âˆ†|M(cid:75) â†’(cid:74)âˆ†0|M(cid:75) is a (unique by coherence)
isomorphism that permutes âˆ†|M to âˆ†0|M. In particular,(cid:74)âˆ† (cid:66) M : A(cid:75) is well-deï¬ned, not

(cid:74)
Let [|Ïˆi,|x1 . . . xni, M ] : A be a well-typed quantum closure. The mapping A 7â†’ hÏˆ|A|Ïˆi
deï¬nes a normal CPU-map hÏˆ|âˆ’|Ïˆi: MâŠ—m2 â†’ C. The interpretation of the quantum closure
is deï¬ned by:

depending on derivations.

hÏˆ|âˆ’|Ïˆi
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ C

âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ MâŠ—n2

4.3 Adequacy of the Denotational Semantics
The next soundness/invariance for the small-step reduction is a key result to obtain adequacy.
i ri â‰¤ 1, the
i rifi of maps is deï¬ned in the obvious pointwise manner and is a normal

(cid:74)[|Ïˆi,|x1 . . . xni, M ] : A(cid:75) := (cid:74)A(cid:75) (cid:74)x1:qbit,...,xn:qbit(cid:66)M:A(cid:75)
Note that for normal CPsU-maps f1, . . . , fn : A â†’ B and ri âˆˆ [0, 1] with P
(convex) sumP
closure. Then(cid:74)P : A(cid:75) =P

CPsU-map.
(cid:73) Proposition 13 (Soundness for the small-step reduction). Let P : A be a well-typed quantum

Q prob(P, Q)(cid:74)Q : A(cid:75).

10

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

L(Î›f0)

f0

Î¹

âˆ’âˆ’âˆ’âˆ’âˆ’â†’ C

âˆ’âˆ’âˆ’âˆ’âˆ’â†’(cid:74)A(cid:75)

(cid:74)âˆ†, y : B, x : A, Î“ (cid:66) M : C(cid:75)FV = (id(cid:74)âˆ†|M(cid:75) âŠ— Î³ âŠ— id(cid:74)Î“|M(cid:75)) â—¦ f (if x, y âˆˆ FV(M)); f (otherwise)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’(cid:74)!Ac(cid:75) (cid:74)c(cid:75)âˆ’âˆ’â†’ C
(cid:74)âˆ†, x : A (cid:66) xB : B(cid:75)FV =(cid:74)B(cid:75) (cid:74)A<:B(cid:75)
((cid:74)(âˆ†, x : A)|M(cid:75)
(cid:74)âˆ†|M(cid:75) âŠ—(cid:74)A(cid:75)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ L((cid:74)A(cid:75) (cid:40)(cid:74)B(cid:75))

(cid:74)âˆ†, x : A, y : B, Î“ (cid:66) M : C(cid:75)FV =(cid:74)C(cid:75) fâˆ’â†’(cid:74)(âˆ†, x : A, y : B, Î“)|M(cid:75)
(cid:74)âˆ† (cid:66) cB : B(cid:75)FV =(cid:74)B(cid:75) (cid:74)!Ac<:B(cid:75)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ LC (dLC )âˆ’1
where: (cid:74)B(cid:75) f /
(cid:74)Î“, !âˆ†, x : A (cid:66) M : B(cid:75)FV =(cid:74)B(cid:75) fâˆ’â†’(cid:74)(Î“, !âˆ†, x : A)|M(cid:75)
xA.M : A (cid:40) B(cid:75)FV =(cid:74)!n+1(A (cid:40) B)(cid:75) (cid:74)!(A(cid:40)B)<:!n+1(A(cid:40)B)(cid:75)
(cid:74)!âˆ†, Î“1 (cid:66) M : A (cid:40) B(cid:75)FV =(cid:74)A (cid:40) B(cid:75) fâˆ’â†’(cid:74)(!âˆ†, Î“1)|M(cid:75)

(cid:74)âˆ† (cid:66) âˆ—n : !n>(cid:75)FV =(cid:74)!n>(cid:75) (cid:74)!><:!n>(cid:75)
(cid:74)âˆ†, x : A (cid:66) M : B(cid:75)FV =(cid:74)B(cid:75) fâˆ’â†’(cid:74)(âˆ†, x : A)|M(cid:75)
(cid:74)âˆ† (cid:66) Î»0xA.M : A (cid:40) B(cid:75)FV =(cid:74)A(cid:75) (cid:40)(cid:74)B(cid:75) Î›f0âˆ’âˆ’â†’(cid:74)âˆ†|M(cid:75)
(cid:74)Î“, !âˆ† (cid:66) Î»n+1

âˆ’âˆ’âˆ’âˆ’âˆ’â†’(cid:74)!!âˆ†|M(cid:75) Âµâˆ’â†’(cid:74)!âˆ†|M(cid:75) =(cid:74)(!âˆ†, Î“)|M(cid:75)
(cid:74)!âˆ†, Î“2 (cid:66) N : A(cid:75)FV =(cid:74)A(cid:75) gâˆ’â†’(cid:74)(!âˆ†, Î“2)|N(cid:75)

âˆ’âˆ’âˆ’âˆ’â†’ L(cid:74)!âˆ†|M(cid:75) (dL)âˆ’1

(cid:74)!âˆ†, Î“1, Î“2 (cid:66) M N : B(cid:75)FV =(cid:74)B(cid:75) Îµâˆ’â†’(cid:74)A (cid:40) B(cid:75) âŠ—(cid:74)A(cid:75) fâŠ—gâˆ’âˆ’âˆ’â†’(cid:74)(!âˆ†, Î“1)|M(cid:75) âŠ—(cid:74)(!âˆ†, Î“2)|N(cid:75)

Î¹âŠ—Î¹âˆ’âˆ’â†’(cid:74)(!âˆ†, Î“1)|M N(cid:75) âŠ—(cid:74)(!âˆ†, Î“2)|M N(cid:75) mergeâˆ’âˆ’âˆ’âˆ’â†’(cid:74)(!âˆ†, Î“1, Î“2)|M N(cid:75)

(cid:74)!âˆ†, Î“1 (cid:66) M : !nA(cid:75)FV =(cid:74)!nA(cid:75) fâˆ’â†’(cid:74)(!âˆ†, Î“1)|M(cid:75)
(cid:74)!âˆ†, Î“2 (cid:66) N : !nB(cid:75)FV =(cid:74)!nB(cid:75) gâˆ’â†’(cid:74)(!âˆ†, Î“2)|N(cid:75)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’(cid:74)!nA(cid:75) âŠ—(cid:74)!nB(cid:75) fâŠ—gâˆ’âˆ’âˆ’â†’
(cid:74)!âˆ†, Î“1, Î“2 (cid:66) hM, Nin : !n(A âŠ— B)(cid:75)FV =(cid:74)!n(A âŠ— B)(cid:75) (dLn )âˆ’1
(cid:74)(!âˆ†, Î“1)|M(cid:75) âŠ—(cid:74)(!âˆ†, Î“2)|N(cid:75) Î¹âŠ—Î¹âˆ’âˆ’â†’(cid:74)(!âˆ†, Î“1)|hM,Ni(cid:75) âŠ—(cid:74)(!âˆ†, Î“2)|hM,Ni(cid:75) mergeâˆ’âˆ’âˆ’âˆ’â†’(cid:74)(!âˆ†, Î“1, Î“2)|hM,Ni(cid:75)
(cid:74)!âˆ†, Î“1, x : !nA, y : !nB (cid:66) M : C(cid:75)FV =(cid:74)C(cid:75) fâˆ’â†’(cid:74)(!âˆ†, Î“1, x : !nA, y : !nB)|M(cid:75)
(cid:74)!âˆ†, Î“1, Î“2 (cid:66) let hxA, yBin = N in M : C(cid:75)FV =(cid:74)C(cid:75) fâˆ’â†’(cid:74)(!âˆ†, Î“1, x : !nA, y : !nB)|M(cid:75)
Î¹âˆ’â†’(cid:74)(!âˆ†, Î“1)|let...(cid:75) âŠ—(cid:74)!nA(cid:75) âŠ—(cid:74)!nB(cid:75) idâŠ—dLn
âˆ’âˆ’âˆ’âˆ’âˆ’â†’(cid:74)(!âˆ†, Î“1)|let...(cid:75) âŠ—(cid:74)!n(A âŠ— B)(cid:75) idâŠ—gâˆ’âˆ’âˆ’â†’
(cid:74)(!âˆ†, Î“1)|let...(cid:75) âŠ—(cid:74)(!âˆ†, Î“2)|N(cid:75) idâŠ—Î¹âˆ’âˆ’âˆ’â†’(cid:74)(!âˆ†, Î“1)|let...(cid:75) âŠ—(cid:74)(!âˆ†, Î“2)|let...(cid:75) mergeâˆ’âˆ’âˆ’âˆ’â†’(cid:74)(!âˆ†, Î“1, Î“2)|let...(cid:75)

(cid:74)!âˆ†, Î“2 (cid:66) N : !n(A âŠ— B)(cid:75)FV =(cid:74)!n(A âŠ— B)(cid:75) gâˆ’â†’(cid:74)(!âˆ†, Î“2)|M(cid:75)

(f

0 deï¬ned similarly)

(cid:74)âˆ† (cid:66) inln
(cid:74)âˆ† (cid:66) inrn

(cid:74)âˆ† (cid:66) M : !nA(cid:75)FV =(cid:74)!nA(cid:75) fâˆ’â†’(cid:74)âˆ†|M(cid:75)
(cid:74)âˆ† (cid:66) N : !nB(cid:75)FV =(cid:74)!nB(cid:75) gâˆ’â†’(cid:74)âˆ†|N(cid:75)

A,B(M) : !n(A âŠ• B)(cid:75)FV =(cid:74)!n(A âŠ• B)(cid:75) LnÏ€1âˆ’âˆ’âˆ’â†’(cid:74)!nA(cid:75) fâˆ’â†’(cid:74)âˆ†|M(cid:75)
A,B(N) : !n(A âŠ• B)(cid:75)FV =(cid:74)!n(A âŠ• B)(cid:75) LnÏ€2âˆ’âˆ’âˆ’â†’(cid:74)!nB(cid:75) gâˆ’â†’(cid:74)âˆ†|N(cid:75)
(cid:74)!âˆ†, Î“1, x : !nA (cid:66) M : C(cid:75)FV =(cid:74)C(cid:75) fâˆ’â†’(cid:74)(!âˆ†, Î“1, x : !nA)|M(cid:75)
(cid:74)!âˆ†, Î“1, y : !nB (cid:66) N : C(cid:75)FV =(cid:74)C(cid:75) gâˆ’â†’(cid:74)(!âˆ†, Î“1, y : !nB)|N(cid:75)
(cid:74)!âˆ†, Î“2 (cid:66) L : !n(A âŠ• B)(cid:75)FV =(cid:74)!n(A âŠ• B)(cid:75) hâˆ’â†’(cid:74)(!âˆ†, Î“2)|L(cid:75)

(cid:74)!âˆ†, Î“1, Î“2 (cid:66) match L withn(xA 7â†’ M | yB 7â†’ N) : C(cid:75)FV =
(cid:74)C(cid:75) hf,giâˆ’âˆ’âˆ’â†’(cid:74)(!âˆ†, Î“1, x : !nA)|M(cid:75) âŠ•(cid:74)(!âˆ†, Î“1, y : !nB)|N(cid:75) Î¹âŠ•Î¹âˆ’âˆ’â†’
((cid:74)(!âˆ†, Î“1)|match...(cid:75) âŠ—(cid:74)!nA(cid:75)) âŠ• ((cid:74)(!âˆ†, Î“1)|match...(cid:75) âŠ—(cid:74)!nB(cid:75)) Î¸âˆ’â†’(cid:74)(!âˆ†, Î“1)|match...(cid:75) âŠ— ((cid:74)!nA(cid:75) âŠ•(cid:74)!nB(cid:75))
âˆ’âˆ’âˆ’âˆ’âˆ’â†’(cid:74)(!âˆ†, Î“1)|match...(cid:75) âŠ—(cid:74)!n(A âŠ• B)(cid:75) idâŠ—hâˆ’âˆ’âˆ’â†’(cid:74)(!âˆ†, Î“1)|match...(cid:75) âŠ—(cid:74)(!âˆ†, Î“2)|L(cid:75)
idâŠ—Î¹âˆ’âˆ’âˆ’â†’(cid:74)(!âˆ†, Î“1)|match...(cid:75) âŠ—(cid:74)(!âˆ†, Î“2)|match...(cid:75) mergeâˆ’âˆ’âˆ’âˆ’â†’(cid:74)(!âˆ†, Î“1, Î“2)|match...(cid:75)

idâŠ—eLn

Table 4 Inductive deï¬nition of the interpretation of typing judgements

/
(

K. Cho and A. Westerbaan

11

(cid:74)
Proof. See Appendix A.
(cid:73) Proposition 14 (Soundness for the big-step reduction). Let P : A be a well-typed quantum

Proof. By Lemmas 7 and 10, Prob(P, Z) def= limnâ†’âˆ probn(P, Z) = probm(P, Z) for some
(cid:74)
Proposition 13.
(cid:73) Theorem 15 (Adequacy). Let P : bit be a quantum closure of type bit. For the interpret-

closure. Then(cid:74)P : A(cid:75) =P
Z Prob(P, Z)(cid:74)Z : A(cid:75), where Z runs over well-typed value closures.
m. It is then easy to obtain(cid:74)P : A(cid:75) =P
Q probm(P, Q)(cid:74)Q : A(cid:75) by induction on m, using
ation(cid:74)P : bit(cid:75): C âŠ• C â†’ C, we have P â‡“ ff =(cid:74)P : bit(cid:75)(1, 0) and P â‡“ tt =(cid:74)P : bit(cid:75)(0, 1).
Proof. By Proposition 14 we have(cid:74)P : bit(cid:75) =P
Z Prob(P, Z)(cid:74)Z : bit(cid:75). Note that for each
follows since(cid:74)[|Ïˆi, Î¨, ff0 ] : bit(cid:75)(Î», Ï) = Î» and(cid:74)[|Ïˆi, Î¨, tt0 ] : bit(cid:75)(Î», Ï) = Ï.

well-typed value closure [|Ïˆi, Î¨, V ] : bit, either V = ff0 or V = tt0. Then the assertion
(cid:74)

Technical Results about von Neumann Algebras
5
Let us sketch how we obtained the two monoidal adjunctions in (1).
(cid:73) Deï¬nition 16. Let â€˜âˆ(X) denote the von Neumann algebra of bounded maps f : X â†’
C on a set X. Addition, multiplication, involution, suprema, and so on, are computed
coordinatewise in â€˜âˆ(X). In fact, â€˜âˆ(X) is simply the X-fold product in vNAMIU of C with
Ï• 7â†’ Ï•(x) as x-th projection. We extend X 7â†’ â€˜âˆ(X) to a functor â€˜âˆ : Setop â†’ vNAMIU
by deï¬ning â€˜âˆ(f)(Ï•) = Ï• â—¦ f for every map f : X â†’ Y (in Set) and Ï• âˆˆ â€˜âˆ(Y ).
Let nsp(A ) be the â€˜normal spectrumâ€™ of a von Neumann algebra A , i.e. the set of normal
MIU-maps Ï•: A â†’ C. We extend A 7â†’ nsp(A ) to a functor nsp: vNAMIU â†’ Setop by
deï¬ning nsp(f)(Ï•) = Ï• â—¦ f for every normal MIU-map f : A â†’ B and Ï• âˆˆ nsp(B) (it is
simply a hom-functor vNAMIU(âˆ’, C)).

Note that any normal MIU-map f : A â†’ â€˜âˆ(X) gives a map g : X â†’ nsp(A ) by

â€œswapping argumentsâ€ â€” g(x)(Ï•) = f(Ï•)(x) â€” and with a little bit more work, we get:
(cid:73) Lemma 17. There is an adjunction nsp a â€˜âˆ.

(cid:74)

iâˆˆI

The following two lemmas describe the normal spectrum of direct products and tensors

each Ï‰ âˆˆ nsp(L

Ai), there is i âˆˆ I and ËœÏ‰ âˆˆ nsp(Ai) with Ï‰ = ËœÏ‰ â—¦ Ï€i.

of von Neumann algebras, and can be proven using standard techniques.
(cid:73) Lemma 18. Let I be a set, and for each i âˆˆ I, let Ai be a von Neumann algebra. For
(cid:74)
(cid:73) Lemma 19. Let A1 and A2 be von Neumann algebras. Then for every Ï‰ âˆˆ nsp(A1 âŠ— A2)
there are unique Ï‰1 âˆˆ A1 and Ï‰2 âˆˆ A2 with Ï‰(a1 âŠ— a2) = Ï‰1(a1) Â· Ï‰2(a2) for all ai âˆˆ Ai. (cid:74)
(cid:73) Corollary 20. The functor nsp: vNAMIU â†’ Setop preserves products, and tensors. (cid:74)
Using that â€˜âˆ(X) is the X-fold product of C in vNAMIU we get:
(cid:73) Corollary 21. The counit of the adjunction nsp a â€˜âˆ is an isomorphism.
(cid:73) Lemma 22. Let X and Y be sets. There is a normal MIU-isomorphism

Ï•: â€˜âˆ(X) âŠ— â€˜âˆ(Y ) âˆ’â†’ â€˜âˆ(X Ã— Y )

given by

Ï•(f âŠ— g)(x, y) = f(x) Â· g(y).

Proof. Use the proof of Proposition 9.2 from [4].

(cid:74)

(cid:74)

12

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

(cid:73) Corollary 23. The adjunction nsp a â€˜âˆ is strong monoidal.
(cid:74)
Let us turn to the second adjunction in (1). In [45] it is shown how the following result
follows from Freydâ€™s Adjoint Functor Theorem (see Theorem V.6.2 of [20]).
(cid:73) Theorem 24 ([45]). The inclusion J : vNAMIU â†’ vNACPsU has a left adjoint.
(cid:74)
(cid:73) Corollary 25. The category vNACPsU is isomorphic to the co-Kleisli category of the
comonad F â—¦ J on vNAMIU induced by F a J .
(cid:74)
Proof. See Theorem 9 of [45], or do Exercise VI.5.2 of [20] (and use the fact that an
(cid:74)
equivalence of categories which is bijective on objects is an isomorphism).
(cid:73) Corollary 26. The adjunction F a J is symmetric monoidal.
Proof. Clearly, J : vNAMIU â†’ vNACPsU is strict symmetric monoidal. From this fact
alone, it follows that the adjunction F a J is symmetric monoidal, see Prop. 14 of [24]. (cid:74)
In our model of the quantum lambda calculus the von Neumann algebras of the form
â€˜âˆ(X) serve as the interpretation of the duplicable types (of the form !A), because â€˜âˆ(X)
carries a âŠ—-monoid structure. Among all von Neumann algebras â€˜âˆ(X) is arguably quite
special and one might wonder if there is a broader class of von Neumann algebras that might
serve as the interpretation of duplicable types (such as the class of all commutative von
Neumann algebras, which includes Lâˆ[0, 1]). The following result settles this matter: no.
Due to space constraints, the proof will appear somewhere else.
(cid:73) Theorem 27. For a von Neumann algebra A the following are equivalent.
1. There is a duplicator on A , that is, a normal positive unital map Âµ: A âŠ— A â†’ A such
that Âµ(1 âŠ— a) = a = Âµ(a âŠ— 1) and Âµ(a âŠ— Âµ(b âŠ— c)) = Âµ(Âµ(a âŠ— b) âŠ— c) for all a, b, c âˆˆ A .

2. A is isomorphic to â€˜âˆ(X) for some set X.
Moreover, there is at most one duplicator on A .
(cid:73) Corollary 28. â€˜âˆ(nsp(A )) is the free âŠ—-monoid on A from vNAMIU.

(cid:74)
(cid:74)

Final Remarks

6
We have given a rather concrete proof of adequacy for the sake of clarity. However, it
seems that we only used the fact that vNAMIU is a â€˜concrete model of the quantum lambda
calculusâ€™ (see Remark 11), and that vNACPsU is â€˜suitablyâ€™ enriched over convex sets. Thus
an abstract result might be distilled from our work stating that any concrete model of the
quantum lambda calculus is adequate when suitably enriched over convex sets, but we have
not pursued this.

We believe selling points of our model are that it is a model for Selinger and Valironâ€™s
original quantum lambda calculus [37] (in Selinger and Valironâ€™s linear fragment [39] the
! modality is absent; in Hasuo and Hoshinoâ€™s language [10] the tensor type qbit âŠ— qbit
does not represent two qubits; and only function types may be duplicable, !(A (cid:40) B), in the
language of Pagani et al. [27]); that it is adequate (Malherbeâ€™s model [21,22] is not known to
be); that the interpretation of ! is rather simple; and that it is formed using von Neumann
algebras, a mathematical classic.

We believe our model could be improved by a more concrete description of(cid:74)A (cid:40) B(cid:75) (as

all the other models have), and by features such as recursion and inductive types (present
in e.g. Hasuo and Hoshinoâ€™s and Paganiâ€™s models), which leaves us with ample material for
future research.

K. Cho and A. Westerbaan

13

Acknowledgements We thank Chris Heunen for spotting a typo.

1

References
P. N. Benton. A mixed linear and non-linear logic: Proofs, terms and models. In CSL â€™94,
volume 933 of LNCS, pages 121â€“135. Springer, 1995.

2 Garrett Birkhoï¬€ and John von Neumann. The logic of quantum mechanics. Annals of

mathematics, pages 823â€“843, 1936.

3 Max Born and Pascual Jordan. Zur quantenmechanik. Zeitschrift fÃ¼r Physik, 34(1):858â€“888,

1925.

4 Kenta Cho. Semantics for a quantum programming language by operator algebras. In QPL

2014, volume 172 of EPTCS, pages 165â€“190, 2014.

6

5 Kenta Cho, Bart Jacobs, Bas Westerbaan, and Abraham Westerbaan. Quotient-

comprehension chains. In QPL 2015, volume 195 of EPTCS, pages 136â€“147, 2015.
John Dauns. Categorical wâˆ—-tensor product. Transactions of the American Mathematical
Society, 166:439â€“456, 1972.
John Dauns. Enveloping W âˆ—-algebras. Journal of Mathematics, 8(4), 1978.

7
8 David J. Foulis and Mary K. Bennett. Eï¬€ect algebras and unsharp quantum logics. Found-

ations of Physics, 24(10):1331â€“1352, 1994.

9 Alain Guichardet. Sur la catÃ©gorie des algebres de von Neumann. Bull. Sci. Math, 90(2):41â€“

64, 1966.
Ichiro Hasuo and Naohiko Hoshino. Semantics of higher-order quantum computation via
geometry of interaction. In LICS 2011, pages 237â€“246. IEEE, 2011.
Ichiro Hasuo and Naohiko Hoshino. Semantics of higher-order quantum computation via
geometry of interaction. Extended version of [10], preprint, 2014.

12 Werner Heisenberg. Quantum-theoretical re-interpretation of kinematic and mechanical

relations. Z. Phys, 33:879â€“893, 1925.
Pascual Jordan. Ãœber verallgemeinerungsmÃ¶glichkeiten des formalismus der quantenmech-
anik. Weidmann, 1933.

14 Richard V. Kadison. A representation theory for commutative topological algebra. American

10

11

13

Mathematical Society, 1951.

15 Richard V. Kadison and John R. Ringrose. Fundamentals of the theory of operator algebras:

Advanced theory, volume 2. American Mathematical Society, 1997.

17

16 Richard V. Kadison and John R. Ringrose. Fundamentals of the Theory of Operator Algeb-

ras: Elementary Theory, volume 1. American Mathematical Society, 1997.
Irving Kaplansky. Projections in Banach algebras. Annals of Mathematics, pages 235â€“249,
1951.

18 Andre Kornell. Quantum collections. arXiv preprint arXiv:1202.2994v1, 2012.
19

Falko Lorenz. Die epimorphismen der ringe von operatoren. Archiv der Mathematik,
20(1):48â€“53, 1969.
Saunders Mac Lane. Categories for the working mathematician. Springer, second edition,
1998.

21 Octavio Malherbe. Categorical models of computation: partially traced categories and

20

presheaf models of quantum computation. PhD thesis, University of Ottawa, 2010.

23

22 Octavio Malherbe, Philip Scott, and Peter Selinger. Presheaf models of quantum compu-
tation: An outline. In Computation, Logic, Games, and Quantum Foundations. The Many
Facets of Samson Abramsky, volume 7860 of LNCS, pages 178â€“194. Springer, 2013.
Paul-AndrÃ© MelliÃ¨s. Categorical models of linear logic revisited. Available on the authorâ€™s
website, 2002.
Paul-AndrÃ© MelliÃ¨s. Categorical semantics of linear logic. Panoramas et synthÃ¨ses, 27:1â€“
196, 2009.

24

14

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

25

Francis J. Murray and John von Neumann. On rings of operators. Annals of Mathematics,
pages 116â€“229, 1936.

26 Michael A Nielsen and Isaac L Chuang. Quantum computation and quantum information.

Cambridge university press, 2010.

27 Michele Pagani, Peter Selinger, and BenoÃ®t Valiron. Applying quantitative semantics to

higher-order quantum computing. In POPL 2014, pages 647â€“658. ACM, 2014.

28 William L Paschke. Inner product modules over Bâˆ—-algebras. Transactions of the American

Mathematical Society, 182:443â€“468, 1973.

29 Vern Paulsen. Completely bounded maps and operator algebras, volume 78. Cambridge

University Press, 2002.

30 Mathys Rennela. Towards a quantum domain theory: Order-enrichment and ï¬xpoints in

31

W âˆ—-algebras. Electronic Notes in Theoretical Computer Science, 308:289â€“307, 2014.
Zhong-Jin Ruan. Subspaces of Câˆ—-algebras. Journal of functional analysis, 76(1):217â€“230,
1988.
ShÃ´ichirÃ´ Sakai. Câˆ—-algebras and W âˆ—-algebras. Springer, 2012.

32
33 Andrea Schalk. What is a categorical model of linear logic? Available on the authorâ€™s

website, 2004.
Irving E. Segal. Postulates for general quantum mechanics. Annals of Mathematics, pages
930â€“948, 1947.
Peter Selinger. Towards a quantum programming language. Mathematical Structures in
Computer Science, 14(04):527â€“586, 2004.
Peter Selinger and BenoÃ®t Valiron. A lambda calculus for quantum computation with
classical control. In TLCA 2005, volume 3461 of LNCS, pages 354â€“368. Springer, 2005.
Peter Selinger and BenoÃ®t Valiron. A lambda calculus for quantum computation with
classical control. Mathematical Structures in Computer Science, 16(3):527â€“552, 2006.
Peter Selinger and BenoÃ®t Valiron. A linear-non-linear model for a computational call-by-
value lambda calculus (extended abstract). In FoSSaCS 2008, volume 4962 of LNCS, pages
81â€“96. Springer, 2008.
Peter Selinger and BenoÃ®t Valiron. On a fully abstract model for a quantum linear functional
language: (extended abstract). In QPL 2006, volume 210 of ENTCS, pages 123â€“137, 2008.
Peter Selinger and BenoÃ®t Valiron. Quantum lambda calculus. In Semantic Techniques in
Quantum Computation, pages 135â€“172. Cambridge University Press, 2009.

34

35

36

37

38

39

40

44

41 Masamichi Takesaki. Theory of operator algebras I. Springer, 2002.
42 BenoÃ®t Valiron. Semantics for a Higher Order Functional Programming Language for

Quantum Computation. PhD thesis, University of Ottawa, 2008.

43 AndrÃ© van Tonder. A lambda calculus for quantum computation. SIAM Journal on Com-

puting, 33(5):1109â€“1135, 2004.
John von Neumann. Wahrscheinlichkeitstheoretischer aufbau der quantenmechanik.
Nachrichten von der Gesellschaft der Wissenschaften zu GÃ¶ttingen, Mathematisch-
Physikalische Klasse, 1927:245â€“272, 1927.

45 Abraham Westerbaan.

arXiv:1501.01020v2, 2014.

Quantum programs as Kleisli maps.

arXiv preprint

A

Proof of Soundness for the Small-Step Reduction

We need some results on the denotational semantics.

K. Cho and A. Westerbaan

15

(cid:73) Lemma 29. Suppose that !âˆ†, Î“1, x : A (cid:66) M : B and !âˆ†, Î“2 (cid:66) V : A, so that !âˆ†, Î“1, Î“2 (cid:66)
M[V /x] : B by Lemma 3. Then the following diagram commute.

(cid:74)B(cid:75)
(cid:74)!âˆ†,Î“2,x:A(cid:66)M:B(cid:75) 

(cid:74)!âˆ†, Î“1(cid:75) âŠ—(cid:74)A(cid:75)

(cid:74)!âˆ†,Î“1,Î“2(cid:66)M[V /x]:B(cid:75)
idâŠ—(cid:74)!âˆ†,Î“2(cid:66)V :A(cid:75)

(cid:74)!âˆ†, Î“1, Î“2(cid:75)
/(cid:74)!âˆ†, Î“1(cid:75) âŠ—(cid:74)!âˆ†, Î“2(cid:75)

merge

(cid:74)
Proof. By induction on M. Note that the interpretation of a value is MIU.
(cid:73) Lemma 30. We have the following equations, when terms M, N and values V, W are
appropriately well-typed.

(cid:74)

0

(cid:74)(Î»

Proof. Straightforward, using Lemma 29.

xA.M)V(cid:75) =(cid:74)M[V /x](cid:75)
(cid:74)let hxA, yBin = hV, Win in M(cid:75) =(cid:74)M[V /x, W/y](cid:75)
A,B(V ) withn(xA 7â†’ M | yB 7â†’ N)(cid:75) =(cid:74)M[V /x](cid:75)
A,B(W) withn(xA 7â†’ M | yB 7â†’ N)(cid:75) =(cid:74)N[W/y](cid:75)

(cid:74)match inln
(cid:74)match inrn
Here we abbreviate(cid:74)âˆ† (cid:66) M : A(cid:75) to(cid:74)M(cid:75).
Note that(cid:74)P : A(cid:75)(0) =(cid:74)P : A(cid:75).
(cid:74)[|Ïˆi,|x1 . . . xmi, M ] : A(cid:75)(l) = MâŠ—l2 âŠ—(cid:74)A(cid:75) idâŠ—(cid:74)xl+1:qbit,...,xm:qbit(cid:66)M:A(cid:75)
xi /âˆˆ FV(M) for all i â‰¤ l. Then(cid:74)P : A(cid:75)(l) =P
Q prob(P, Q)(cid:74)Q : A(cid:75)(l).

(cid:73) Deï¬nition 31. Let [|Ïˆi,|x1 . . . xmi, M ] : A be a well-typed quantum closure such that
xi /âˆˆ FV(M) for all i â‰¤ l. Then we deï¬ne:

hÏˆ|âˆ’|Ïˆi
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ C
(cid:73) Lemma 32. Let P = [|Ïˆi,|x1 . . . xmi, M ] : A be a well-typed quantum closure such that

âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ MâŠ—m2

To prove Proposition 13 by induction, we need to strengthen the statement into Lemma 32.

Proof. We prove it by induction on terms M. If M is a value, then it holds by the deï¬nition
of prob. In the other induction steps, we prove the assertion by cases.
Consider the induction step for M N, and the case where M is not a value. Then the
only possible reductions from P = [ Ïˆ, Î¨, M N ] are [ Ïˆ, Î¨, M N ] â†’p [ Ïˆ0, Î¨0, M0N ] when
[ Ïˆ, Î¨, M ] â†’p [ Ïˆ0, Î¨0, M0 ]. Without loss of generality,2 we may assume that

l = |y1 . . . ylz1 . . . zkx1 . . . xhi

such that x1 : qbit, . . . , xh : qbit (cid:66) M : A (cid:40) B and z1 : qbit, . . . , zk : qbit (cid:66) N : A. We

will simply write(cid:74)M(cid:75) for(cid:74)x1 : qbit, . . . , xh : qbit (cid:66) M : A (cid:40) B(cid:75) and(cid:74)N(cid:75) similarly. Then
(cid:74)[ Ïˆ, Î¨, M N ] : B(cid:75)(l)
= MâŠ—l2 âŠ—(cid:74)B(cid:75) idâŠ—Îµâˆ’âˆ’âˆ’â†’ MâŠ—l2 âŠ—(cid:74)A (cid:40) B(cid:75) âŠ—(cid:74)A(cid:75) idâŠ—(cid:74)M(cid:75)âŠ—(cid:74)N(cid:75)
= MâŠ—l2 âŠ—(cid:74)B(cid:75) idâŠ—Îµâˆ’âˆ’âˆ’â†’ MâŠ—l2 âŠ—(cid:74)A (cid:40) B(cid:75) âŠ—(cid:74)A(cid:75) idâŠ—Î³âˆ’âˆ’âˆ’â†’ MâŠ—l2 âŠ—(cid:74)A(cid:75) âŠ—(cid:74)A (cid:40) B(cid:75)

âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ MâŠ—l2 âŠ— MâŠ—h2 âŠ— MâŠ—k2

idâŠ—Î³âˆ’âˆ’âˆ’â†’ MâŠ—l2 âŠ— MâŠ—k2 âŠ— MâŠ—h2
idâŠ—(cid:74)N(cid:75)âŠ—id
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ MâŠ—(l+k)

âˆ’âˆ’âˆ’âˆ’âˆ’â†’ MâŠ—(l+k)

hÏˆ|âˆ’|Ïˆi
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ C

hÏˆ|âˆ’|Ïˆi
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ C

2

2

âŠ— MâŠ—h2

âŠ—(cid:74)A (cid:40) B(cid:75) idâŠ—(cid:74)M(cid:75)

2 A permutation of variables in Î¨ which keeps the ï¬rst l variables, with the permutation of the correspond-

ing qubits in |Ïˆi, does not change(cid:74)P : A(cid:75)(l). The same is true for the operational semantics [39, Â§3.2].

/
/

/
O
O
16

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

hÏˆi|âˆ’|Ïˆii

iâˆˆI

iâˆˆI

pi

2

MâŠ—(l+k)

2

âŠ— MâŠ—h2

hÏˆ|âˆ’|Ïˆi
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ C

âˆ’âˆ’âˆ’âˆ’âˆ’â†’ MâŠ—(l+k)

2

âŠ— MâŠ—hi2

âˆ’âˆ’âˆ’âˆ’âˆ’â†’ MâŠ—(l+k)

2

Next consider the case where M = U and N = hx1, . . . , xki0. Without loss of generality
we may assume P = [|Ïˆi, Î¨, Uhx1, . . . , xki ] with l = |y1 . . . ylx1 . . . xkz1 . . . zhi. The only
reduction from P is [|Ïˆi, Î¨, Uhx1, . . . , xki ] â†’1 [|Ïˆ0i, Î¨,hx1, . . . , xki ] =: Q, where |Ïˆ0i =

Let [ Ïˆ, Î¨, M ] â†’pi [ Ïˆi, Î¨i, Mi ] (i âˆˆ I) be all the reductions from [ Ïˆ, Î¨, M ]. By IH, we have
âŠ—(cid:74)A (cid:40) B(cid:75) idâŠ—(cid:74)M(cid:75)
=(cid:74)[ Ïˆ, Î¨, M ] : A (cid:40) B(cid:75)(l+k)
=X
pi(cid:74)[ Ïˆi, Î¨i, Mi ] : A (cid:40) B(cid:75)(l+k)
(cid:16)MâŠ—(l+k)
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ C(cid:17)
=X
âŠ—(cid:74)A (cid:40) B(cid:75) idâŠ—(cid:74)Mi(cid:75)
It is then straightforward to see that(cid:74)[ Ïˆ, Î¨, M N ] : B(cid:75)(l) =P
i pi(cid:74)[ Ïˆi, Î¨i, MiN ] : B(cid:75)(l).
(Il âŠ— U âŠ— Ih)|Ïˆi (In denotes the 2n Ã— 2n identity matrix). We need to show that (cid:74)P :
qbitâŠ—k(cid:75)(l) =(cid:74)Q : qbitâŠ—k(cid:75)(l). Note that
(cid:74)x1 : qbit, . . . , xk : qbit (cid:66) Uhx1, . . . , xki : qbitâŠ—k(cid:75) = fU : MâŠ—k2 â†’ MâŠ—k2
(cid:74)P : qbitâŠ—k(cid:75)(l) = MâŠ—l2 âŠ— MâŠ—k2
(cid:74)x1 : qbit, . . . , xk : qbit (cid:66) hx1, . . . , xki : qbitâŠ—k(cid:75) = id: MâŠ—k2 â†’ MâŠ—k2
(cid:74)Q : qbitâŠ—k(cid:75)(l) = MâŠ—l2 âŠ— MâŠ—k2
(cid:74)P : qbitâŠ—k(cid:75)(l)(A âŠ— B) = hÏˆ|(id âŠ— Î¹)((id âŠ— fU)(A âŠ— B))|Ïˆi

idâŠ—Î¹âˆ’âˆ’âˆ’â†’ MâŠ—(l+k+h)
For each elementary tensor A âŠ— B âˆˆ MâŠ—l2 âŠ— MâŠ—k2 ,

On the other hand, we have

idâŠ—fUâˆ’âˆ’âˆ’âˆ’â†’ MâŠ—l2 âŠ— MâŠ—k2

idâŠ—Î¹âˆ’âˆ’âˆ’â†’ MâŠ—(l+k+h)

2

hÏˆ0|âˆ’|Ïˆ0i
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ C

hÏˆ|âˆ’|Ïˆi
âˆ’âˆ’âˆ’âˆ’âˆ’â†’ C

Thus we have

and hence

2

= hÏˆ|A âŠ— (Uâ€ BU) âŠ— Ih|Ïˆi
= hÏˆ|(Il âŠ— Uâ€  âŠ— Ih)(A âŠ— B âŠ— Ih)(Il âŠ— U âŠ— Ih)|Ïˆi
= hÏˆ0|(id âŠ— Î¹)(A âŠ— B)|Ïˆ0i

=(cid:74)Q : qbitâŠ—k(cid:75)(l)(A âŠ— B)
We conclude that(cid:74)P : qbitâŠ—k(cid:75)(l) =(cid:74)Q : qbitâŠ—k(cid:75)(l).

Consider the case where M N is of the form (Î»x.M)V . Only the reduction is [|Ïˆi, Î¨, (Î»x.M)V ] â†’1

[|Ïˆi, Î¨, M[V /x] ]. The assertion holds immediately by Lemma 30.

The other cases in the induction step M N can be shown similarly. We can prove the
(cid:74)

other induction steps similarly by cases.

